/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { HeadingLevel } from "./types/index";
import { BannerType } from "./components/post-banner/banner-types";
import { SwitchVariant } from "./components/post-language-switch/switch-variants";
import { Placement } from "@floating-ui/dom";
import { Orientation } from "./components/post-slider/orientation";
export { HeadingLevel } from "./types/index";
export { BannerType } from "./components/post-banner/banner-types";
export { SwitchVariant } from "./components/post-language-switch/switch-variants";
export { Placement } from "@floating-ui/dom";
export { Orientation } from "./components/post-slider/orientation";
export namespace Components {
    interface PostAccordion {
        /**
          * Collapses all `post-accordion-item`.
         */
        "collapseAll": () => Promise<void>;
        /**
          * Expands all `post-accordion-item`.  If `multiple="true"` is not set and all items are closed, it will open the first one. Otherwise, it will keep the opened one.
         */
        "expandAll": () => Promise<void>;
        /**
          * Defines the hierarchical level of the `post-accordion-item` headers within the headings structure.
         */
        "headingLevel": HeadingLevel;
        /**
          * If `true`, multiple `post-accordion-item` can be open at the same time.
          * @default false
         */
        "multiple": boolean;
        /**
          * Toggles the `post-accordion-item` with the given id.
         */
        "toggle": (id: string) => Promise<void>;
    }
    interface PostAccordionItem {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Defines the hierarchical level of the accordion item header within the headings structure.
          * @deprecated set the `heading-level` property on the parent `post-accordion` instead.
         */
        "headingLevel"?: HeadingLevel;
        /**
          * Triggers the collapse programmatically.
         */
        "toggle": (force?: boolean) => Promise<boolean>;
    }
    interface PostAvatar {
        /**
          * Provides a custom description for the avatar, used for accessibility purposes.
         */
        "description"?: string;
        /**
          * Defines the users email address associated with a gravatar profile picture.
         */
        "email"?: string;
        /**
          * Defines the users firstname.
         */
        "firstname": string;
        /**
          * Defines the users lastname.
         */
        "lastname"?: string;
        /**
          * Defines the company internal userId.<post-banner type="warning" data-size="sm"><p>Can only be used on post.ch domains!</p></post-banner>
         */
        "userid"?: string;
    }
    interface PostBackToTop {
        /**
          * The label of the back-to-top button, intended solely for accessibility purposes. This label is always hidden from view.
         */
        "label": string;
    }
    interface PostBanner {
        /**
          * Triggers banner dismissal programmatically (same as clicking on the close button (Ã—)).
         */
        "dismiss": () => Promise<void>;
        /**
          * The type of the banner.
          * @default 'info'
         */
        "type": BannerType;
    }
    interface PostBreadcrumbItem {
        /**
          * The optional URL to which the breadcrumb item will link.
         */
        "url"?: string | URL;
    }
    interface PostBreadcrumbs {
        /**
          * The text label for the home breadcrumb item.
          * @default 'Home'
         */
        "homeText": string;
        /**
          * The URL for the home breadcrumb item.
         */
        "homeUrl": string;
    }
    /**
     * @class PostCardControl - representing a stencil component
     */
    interface PostCardControl {
        /**
          * Defines the `checked` attribute of the control. If `true`, the control is selected at its value will be included in the forms' data.
          * @default false
         */
        "checked": boolean;
        /**
          * Defines the description in the control-label.
         */
        "description"?: string;
        /**
          * Defines the `disabled` attribute of the control. If `true`, the user can not interact with the control and the controls value will not be included in the forms' data.
          * @default false
         */
        "disabled": boolean;
        /**
          * A hidden public method to reset the group controls `checked` state to `false`.
         */
        "groupReset": () => Promise<void>;
        /**
          * Defines the icon `name` inside the card. <post-banner data-size="sm"><p>If not set the icon will not show up.</p></post-banner>
         */
        "icon"?: string;
        /**
          * Defines the text in the control-label.
         */
        "label": string;
        /**
          * Defines the `name` attribute of the control. <post-banner data-size="sm"><p>This is a required property, when the control should participate in a native `form`. If not specified, a native `form` will never contain this controls value.</p></post-banner> <post-banner data-size="sm"><p>This is a required property, when the control is used with type `radio`.</p></post-banner>
         */
        "name"?: string;
        /**
          * A public method to reset the controls `checked` and `validity` state. The validity state is set to `undefined`, so it's neither valid nor invalid.
         */
        "reset": () => Promise<void>;
        /**
          * Defines the `type` attribute of the control.
         */
        "type": 'checkbox' | 'radio';
        /**
          * Defines the validation `validity` of the control. To reset validity to an undefined state, simply remove the attribute from the control.
         */
        "validity"?: boolean;
        /**
          * Defines the `value` attribute of the control. <post-banner data-size="sm"><p>This is a required property, when the control is used with type `radio`.</p></post-banner>
         */
        "value"?: string;
    }
    interface PostClosebutton {
    }
    interface PostCollapsible {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Triggers the collapse programmatically.  If there is a collapsing transition running already, it will be reversed.
         */
        "toggle": (open?: boolean) => Promise<boolean>;
    }
    interface PostCollapsibleTrigger {
        /**
          * Link the trigger to a post-collapsible with this id
         */
        "for": string;
        /**
          * Update the "aria-controls" and "aria-expanded" attributes on the trigger button
         */
        "update": () => Promise<void>;
    }
    interface PostFooter {
        /**
          * The label to add to the footer (visually hidden).
         */
        "label": string;
    }
    interface PostHeader {
        /**
          * Toggles the mobile navigation.
         */
        "toggleMobileMenu": (force?: boolean) => Promise<void>;
    }
    /**
     * @class PostIcon - representing a stencil component
     */
    interface PostIcon {
        /**
          * The name of the animation.
         */
        "animation"?: Animation;
        /**
          * The base path, where the icons are located (must be a public url).<br/>Leave this field empty to use the default cdn url.
         */
        "base"?: string;
        /**
          * When set to `true`, the icon will be flipped horizontally.
          * @default false
         */
        "flipH"?: boolean;
        /**
          * When set to `true`, the icon will be flipped vertically.
          * @default false
         */
        "flipV"?: boolean;
        /**
          * The name/id of the icon (e.g. 1000, 1001, ...).
         */
        "name": string;
        /**
          * The number of degree for the css rotate transformation.
         */
        "rotate"?: number;
        /**
          * The number for the css scale transformation.
         */
        "scale"?: number;
    }
    interface PostLanguageOption {
        /**
          * If set to `true`, the language option is considered the current language for the page.
         */
        "active"?: boolean;
        /**
          * The ISO 639 language code, formatted according to [RFC 5646 (also known as BCP 47)](https://datatracker.ietf.org/doc/html/rfc5646). For example, "de".
         */
        "code": string;
        /**
          * The full name of the language. For example, "Deutsch".
         */
        "name"?: string;
        /**
          * Selects the language option programmatically.
         */
        "select": () => Promise<void>;
        /**
          * The URL used for the href attribute of the internal anchor. This field is optional; if not provided, a button will be used internally instead of an anchor.
         */
        "url"?: string;
        /**
          * To communicate the variant prop from the parent (post-language-switch) component to the child (post-language-option) component. See parent docs for a description about the property itself.
         */
        "variant"?: SwitchVariant;
    }
    interface PostLanguageSwitch {
        /**
          * A title for the list of language options
         */
        "caption": string;
        /**
          * A descriptive text for the list of language options
         */
        "description": string;
        /**
          * Whether the component is rendered as a list or a menu
          * @default 'list'
         */
        "variant": SwitchVariant;
    }
    interface PostLinkarea {
    }
    interface PostList {
        /**
          * The list can become horizontal by setting `horizontal="true"` or just `horizontal`
          * @default false
         */
        "horizontal": boolean;
        /**
          * If `true`, the list title will be hidden. Otherwise, it will be displayed.`
          * @default false
         */
        "titleHidden": boolean;
    }
    interface PostListItem {
    }
    interface PostLogo {
        /**
          * The URL to which the user is redirected upon clicking the logo.
         */
        "url"?: string | URL;
    }
    interface PostMainnavigation {
    }
    interface PostMegadropdown {
        /**
          * Sets focus to the first focusable element within the component.
         */
        "focusFirst": () => Promise<void>;
        /**
          * Hides the dropdown with an animation.
         */
        "hide": (focusParent?: boolean, forceClose?: boolean) => Promise<void>;
        /**
          * Displays the dropdown.
         */
        "show": () => Promise<void>;
        /**
          * Toggles the dropdown visibility based on its current state.
         */
        "toggle": () => Promise<void>;
    }
    interface PostMegadropdownTrigger {
        /**
          * ID of the mega dropdown element that this trigger is linked to. Used to open and close the specified mega dropdown.
         */
        "for": string;
    }
    interface PostMenu {
        /**
          * Hides the popover menu and restores focus to the previously focused element.
         */
        "hide": () => Promise<void>;
        /**
          * An accessible name for the menu.
         */
        "label"?: string;
        /**
          * Defines the position of the menu relative to its trigger. Menus are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries. For supported values and behavior details, see the [Floating UI placement documentation](https://floating-ui.com/docs/computePosition#placement).
          * @default 'bottom'
         */
        "placement"?: Placement;
        /**
          * Displays the popover menu, focusing the first menu item.
          * @param target - The HTML element relative to which the popover menu should be displayed.
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggles the menu visibility based on its current state.
         */
        "toggle": (target: HTMLElement) => Promise<void>;
    }
    interface PostMenuItem {
    }
    interface PostMenuTrigger {
        /**
          * ID of the menu element that this trigger is linked to. Used to open and close the specified menu.
         */
        "for": string;
    }
    interface PostPopover {
        /**
          * Show a little indicator arrow
          * @default true
         */
        "arrow"?: boolean;
        /**
          * Define the caption of the close button for assistive technology
         */
        "closeButtonCaption": string;
        /**
          * Programmatically hide this popover
         */
        "hide": () => Promise<void>;
        /**
          * Defines the position of the popover relative to its trigger. Popovers are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries. For supported values and behavior details, see the [Floating UI placement documentation](https://floating-ui.com/docs/computePosition#placement).
          * @default 'top'
         */
        "placement"?: Placement;
        /**
          * Programmatically display the popover
          * @param target An element with [data-popover-target="id"] where the popover should be shown
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggle popover display
          * @param target An element with [data-popover-target="id"] where the popover should be anchored to
          * @param force Pass true to always show or false to always hide
         */
        "toggle": (target: HTMLElement, force?: boolean) => Promise<void>;
    }
    interface PostPopovercontainer {
        /**
          * Animation style
          * @default null
         */
        "animation"?: 'pop-in' | null;
        /**
          * Whether or not to display a little pointer arrow
          * @default false
         */
        "arrow"?: boolean;
        /**
          * Gap between the edge of the page and the popovercontainer
          * @default 8
         */
        "edgeGap"?: number;
        /**
          * Programmatically hide the popovercontainer
         */
        "hide": () => Promise<void>;
        /**
          * Whether or not the popovercontainer should close when user clicks outside of it
          * @default false
         */
        "manualClose": boolean;
        /**
          * Defines the placement of the popovercontainer according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Popovercontainers are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
          * @default 'top'
         */
        "placement"?: Placement;
        /**
          * Enables a safespace through which the cursor can be moved without the popover being disabled
         */
        "safeSpace"?: 'triangle' | 'trapezoid';
        /**
          * Programmatically display the popovercontainer
          * @param target An element with [data-popover-target="id"] where the popovercontainer should be shown
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggle popovercontainer display
          * @param target An element with [data-popover-target="id"] where the popovercontainer should be shown
          * @param force Pass true to always show or false to always hide
         */
        "toggle": (target: HTMLElement, force?: boolean) => Promise<boolean>;
    }
    interface PostRating {
        /**
          * Defines the rating that the component should show.
          * @default 0
         */
        "currentRating": number;
        /**
          * Defines a hidden label for the component.
          * @default 'Rating'
         */
        "label": string;
        /**
          * Defines if the component is readonly or not. This usually should be used together with the `currentRating` property.
          * @default false
         */
        "readonly": boolean;
        /**
          * Defines the total amount of stars rendered in the component.
          * @default 5
         */
        "stars": number;
    }
    interface PostSlider {
        /**
          * The greatest value in the range of permitted values.
          * @default 100
         */
        "max": number;
        /**
          * The lowest value in the range of permitted values.
          * @default 0
         */
        "min": number;
        /**
          * The orientation of the slider: "horizontal" or "vertical".
          * @default 'horizontal'
         */
        "orient": Orientation;
        /**
          * If true, the slider has two thumbs allowing for range selection.
          * @default false
         */
        "range": boolean;
        /**
          * The granularity that the value must adhere to.
          * @default 1
         */
        "step": number | 'any';
        /**
          * The number or range initially selected.
         */
        "value"?: number | [number, number];
    }
    interface PostTabHeader {
        /**
          * The name of the panel controlled by the tab header.
         */
        "panel": string;
    }
    interface PostTabPanel {
        /**
          * The name of the panel, used to associate it with a tab header.
         */
        "name": string;
    }
    interface PostTabs {
        /**
          * The name of the panel that is initially shown. If not specified, it defaults to the panel associated with the first tab.  **Changing this value after initialization has no effect.**
         */
        "activePanel"?: HTMLPostTabPanelElement['name'];
        /**
          * When set to true, this property allows the tabs container to span the full width of the screen, from edge to edge.
          * @default false
         */
        "fullWidth": boolean;
        /**
          * Shows the panel with the given name and selects its associated tab. Any other panel that was previously shown becomes hidden and its associated tab is unselected.
         */
        "show": (panelName: string) => Promise<void>;
    }
    interface PostTogglebutton {
        /**
          * If `true`, the button is in the "on" state, otherwise it is in the "off" state.
          * @default false
         */
        "toggled": boolean;
    }
    interface PostTooltip {
        /**
          * Choose a tooltip animation
         */
        "animation"?: 'pop-in';
        /**
          * Whether or not to display a little pointer arrow
          * @default false
         */
        "arrow"?: boolean;
        /**
          * Programmatically hide this tooltip.
         */
        "hide": () => Promise<void>;
        /**
          * Indicates the open state of the tooltip
          * @default false
         */
        "open": boolean;
        /**
          * Defines the position of the tooltip relative to its trigger. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries. For supported values and behavior details, see the [Floating UI placement documentation](https://floating-ui.com/docs/computePosition#placement).
          * @default 'top'
         */
        "placement"?: Placement;
        /**
          * Programmatically display the tooltip.
          * @param target An element where the tooltip should be shown
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggle tooltip display.
          * @param target An element where the tooltip should be shown
          * @param force Pass true to always show or false to always hide
         */
        "toggle": (target: HTMLElement, force?: boolean) => Promise<void>;
    }
    interface PostTooltipTrigger {
        /**
          * Delay (in milliseconds) before the tooltip is shown.
          * @default 0
         */
        "delay": number;
        /**
          * ID of the tooltip element that this trigger is linked to.
         */
        "for": string;
    }
}
export interface PostBannerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostBannerElement;
}
export interface PostCardControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostCardControlElement;
}
export interface PostCollapsibleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostCollapsibleElement;
}
export interface PostLanguageOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostLanguageOptionElement;
}
export interface PostMegadropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostMegadropdownElement;
}
export interface PostMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostMenuElement;
}
export interface PostPopovercontainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostPopovercontainerElement;
}
export interface PostRatingCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostRatingElement;
}
export interface PostSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostSliderElement;
}
export interface PostTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostTabsElement;
}
declare global {
    interface HTMLPostAccordionElement extends Components.PostAccordion, HTMLStencilElement {
    }
    var HTMLPostAccordionElement: {
        prototype: HTMLPostAccordionElement;
        new (): HTMLPostAccordionElement;
    };
    interface HTMLPostAccordionItemElement extends Components.PostAccordionItem, HTMLStencilElement {
    }
    var HTMLPostAccordionItemElement: {
        prototype: HTMLPostAccordionItemElement;
        new (): HTMLPostAccordionItemElement;
    };
    interface HTMLPostAvatarElement extends Components.PostAvatar, HTMLStencilElement {
    }
    var HTMLPostAvatarElement: {
        prototype: HTMLPostAvatarElement;
        new (): HTMLPostAvatarElement;
    };
    interface HTMLPostBackToTopElement extends Components.PostBackToTop, HTMLStencilElement {
    }
    var HTMLPostBackToTopElement: {
        prototype: HTMLPostBackToTopElement;
        new (): HTMLPostBackToTopElement;
    };
    interface HTMLPostBannerElementEventMap {
        "postDismissed": void;
    }
    interface HTMLPostBannerElement extends Components.PostBanner, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostBannerElementEventMap>(type: K, listener: (this: HTMLPostBannerElement, ev: PostBannerCustomEvent<HTMLPostBannerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostBannerElementEventMap>(type: K, listener: (this: HTMLPostBannerElement, ev: PostBannerCustomEvent<HTMLPostBannerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostBannerElement: {
        prototype: HTMLPostBannerElement;
        new (): HTMLPostBannerElement;
    };
    interface HTMLPostBreadcrumbItemElement extends Components.PostBreadcrumbItem, HTMLStencilElement {
    }
    var HTMLPostBreadcrumbItemElement: {
        prototype: HTMLPostBreadcrumbItemElement;
        new (): HTMLPostBreadcrumbItemElement;
    };
    interface HTMLPostBreadcrumbsElement extends Components.PostBreadcrumbs, HTMLStencilElement {
    }
    var HTMLPostBreadcrumbsElement: {
        prototype: HTMLPostBreadcrumbsElement;
        new (): HTMLPostBreadcrumbsElement;
    };
    interface HTMLPostCardControlElementEventMap {
        "postInput": { state: boolean; value: string };
        "postChange": { state: boolean; value: string };
    }
    /**
     * @class PostCardControl - representing a stencil component
     */
    interface HTMLPostCardControlElement extends Components.PostCardControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostCardControlElementEventMap>(type: K, listener: (this: HTMLPostCardControlElement, ev: PostCardControlCustomEvent<HTMLPostCardControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostCardControlElementEventMap>(type: K, listener: (this: HTMLPostCardControlElement, ev: PostCardControlCustomEvent<HTMLPostCardControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostCardControlElement: {
        prototype: HTMLPostCardControlElement;
        new (): HTMLPostCardControlElement;
    };
    interface HTMLPostClosebuttonElement extends Components.PostClosebutton, HTMLStencilElement {
    }
    var HTMLPostClosebuttonElement: {
        prototype: HTMLPostClosebuttonElement;
        new (): HTMLPostClosebuttonElement;
    };
    interface HTMLPostCollapsibleElementEventMap {
        "postToggle": boolean;
    }
    interface HTMLPostCollapsibleElement extends Components.PostCollapsible, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostCollapsibleElementEventMap>(type: K, listener: (this: HTMLPostCollapsibleElement, ev: PostCollapsibleCustomEvent<HTMLPostCollapsibleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostCollapsibleElementEventMap>(type: K, listener: (this: HTMLPostCollapsibleElement, ev: PostCollapsibleCustomEvent<HTMLPostCollapsibleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostCollapsibleElement: {
        prototype: HTMLPostCollapsibleElement;
        new (): HTMLPostCollapsibleElement;
    };
    interface HTMLPostCollapsibleTriggerElement extends Components.PostCollapsibleTrigger, HTMLStencilElement {
    }
    var HTMLPostCollapsibleTriggerElement: {
        prototype: HTMLPostCollapsibleTriggerElement;
        new (): HTMLPostCollapsibleTriggerElement;
    };
    interface HTMLPostFooterElement extends Components.PostFooter, HTMLStencilElement {
    }
    var HTMLPostFooterElement: {
        prototype: HTMLPostFooterElement;
        new (): HTMLPostFooterElement;
    };
    interface HTMLPostHeaderElement extends Components.PostHeader, HTMLStencilElement {
    }
    var HTMLPostHeaderElement: {
        prototype: HTMLPostHeaderElement;
        new (): HTMLPostHeaderElement;
    };
    /**
     * @class PostIcon - representing a stencil component
     */
    interface HTMLPostIconElement extends Components.PostIcon, HTMLStencilElement {
    }
    var HTMLPostIconElement: {
        prototype: HTMLPostIconElement;
        new (): HTMLPostIconElement;
    };
    interface HTMLPostLanguageOptionElementEventMap {
        "postChange": string;
        "postLanguageOptionInitiallyActive": string;
    }
    interface HTMLPostLanguageOptionElement extends Components.PostLanguageOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostLanguageOptionElementEventMap>(type: K, listener: (this: HTMLPostLanguageOptionElement, ev: PostLanguageOptionCustomEvent<HTMLPostLanguageOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostLanguageOptionElementEventMap>(type: K, listener: (this: HTMLPostLanguageOptionElement, ev: PostLanguageOptionCustomEvent<HTMLPostLanguageOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostLanguageOptionElement: {
        prototype: HTMLPostLanguageOptionElement;
        new (): HTMLPostLanguageOptionElement;
    };
    interface HTMLPostLanguageSwitchElement extends Components.PostLanguageSwitch, HTMLStencilElement {
    }
    var HTMLPostLanguageSwitchElement: {
        prototype: HTMLPostLanguageSwitchElement;
        new (): HTMLPostLanguageSwitchElement;
    };
    interface HTMLPostLinkareaElement extends Components.PostLinkarea, HTMLStencilElement {
    }
    var HTMLPostLinkareaElement: {
        prototype: HTMLPostLinkareaElement;
        new (): HTMLPostLinkareaElement;
    };
    interface HTMLPostListElement extends Components.PostList, HTMLStencilElement {
    }
    var HTMLPostListElement: {
        prototype: HTMLPostListElement;
        new (): HTMLPostListElement;
    };
    interface HTMLPostListItemElement extends Components.PostListItem, HTMLStencilElement {
    }
    var HTMLPostListItemElement: {
        prototype: HTMLPostListItemElement;
        new (): HTMLPostListItemElement;
    };
    interface HTMLPostLogoElement extends Components.PostLogo, HTMLStencilElement {
    }
    var HTMLPostLogoElement: {
        prototype: HTMLPostLogoElement;
        new (): HTMLPostLogoElement;
    };
    interface HTMLPostMainnavigationElement extends Components.PostMainnavigation, HTMLStencilElement {
    }
    var HTMLPostMainnavigationElement: {
        prototype: HTMLPostMainnavigationElement;
        new (): HTMLPostMainnavigationElement;
    };
    interface HTMLPostMegadropdownElementEventMap {
        "postToggleMegadropdown": { isVisible: boolean; focusParent?: boolean };
    }
    interface HTMLPostMegadropdownElement extends Components.PostMegadropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostMegadropdownElementEventMap>(type: K, listener: (this: HTMLPostMegadropdownElement, ev: PostMegadropdownCustomEvent<HTMLPostMegadropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostMegadropdownElementEventMap>(type: K, listener: (this: HTMLPostMegadropdownElement, ev: PostMegadropdownCustomEvent<HTMLPostMegadropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostMegadropdownElement: {
        prototype: HTMLPostMegadropdownElement;
        new (): HTMLPostMegadropdownElement;
    };
    interface HTMLPostMegadropdownTriggerElement extends Components.PostMegadropdownTrigger, HTMLStencilElement {
    }
    var HTMLPostMegadropdownTriggerElement: {
        prototype: HTMLPostMegadropdownTriggerElement;
        new (): HTMLPostMegadropdownTriggerElement;
    };
    interface HTMLPostMenuElementEventMap {
        "toggleMenu": boolean;
    }
    interface HTMLPostMenuElement extends Components.PostMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostMenuElementEventMap>(type: K, listener: (this: HTMLPostMenuElement, ev: PostMenuCustomEvent<HTMLPostMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostMenuElementEventMap>(type: K, listener: (this: HTMLPostMenuElement, ev: PostMenuCustomEvent<HTMLPostMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostMenuElement: {
        prototype: HTMLPostMenuElement;
        new (): HTMLPostMenuElement;
    };
    interface HTMLPostMenuItemElement extends Components.PostMenuItem, HTMLStencilElement {
    }
    var HTMLPostMenuItemElement: {
        prototype: HTMLPostMenuItemElement;
        new (): HTMLPostMenuItemElement;
    };
    interface HTMLPostMenuTriggerElement extends Components.PostMenuTrigger, HTMLStencilElement {
    }
    var HTMLPostMenuTriggerElement: {
        prototype: HTMLPostMenuTriggerElement;
        new (): HTMLPostMenuTriggerElement;
    };
    interface HTMLPostPopoverElement extends Components.PostPopover, HTMLStencilElement {
    }
    var HTMLPostPopoverElement: {
        prototype: HTMLPostPopoverElement;
        new (): HTMLPostPopoverElement;
    };
    interface HTMLPostPopovercontainerElementEventMap {
        "postToggle": { isOpen: boolean; first?: boolean };
    }
    interface HTMLPostPopovercontainerElement extends Components.PostPopovercontainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostPopovercontainerElementEventMap>(type: K, listener: (this: HTMLPostPopovercontainerElement, ev: PostPopovercontainerCustomEvent<HTMLPostPopovercontainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostPopovercontainerElementEventMap>(type: K, listener: (this: HTMLPostPopovercontainerElement, ev: PostPopovercontainerCustomEvent<HTMLPostPopovercontainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostPopovercontainerElement: {
        prototype: HTMLPostPopovercontainerElement;
        new (): HTMLPostPopovercontainerElement;
    };
    interface HTMLPostRatingElementEventMap {
        "postInput": { value: number };
        "postChange": { value: number };
    }
    interface HTMLPostRatingElement extends Components.PostRating, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostRatingElementEventMap>(type: K, listener: (this: HTMLPostRatingElement, ev: PostRatingCustomEvent<HTMLPostRatingElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostRatingElementEventMap>(type: K, listener: (this: HTMLPostRatingElement, ev: PostRatingCustomEvent<HTMLPostRatingElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostRatingElement: {
        prototype: HTMLPostRatingElement;
        new (): HTMLPostRatingElement;
    };
    interface HTMLPostSliderElementEventMap {
        "postInput": number | [number, number];
        "postChange": number | [number, number];
    }
    interface HTMLPostSliderElement extends Components.PostSlider, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostSliderElementEventMap>(type: K, listener: (this: HTMLPostSliderElement, ev: PostSliderCustomEvent<HTMLPostSliderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostSliderElementEventMap>(type: K, listener: (this: HTMLPostSliderElement, ev: PostSliderCustomEvent<HTMLPostSliderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostSliderElement: {
        prototype: HTMLPostSliderElement;
        new (): HTMLPostSliderElement;
    };
    interface HTMLPostTabHeaderElement extends Components.PostTabHeader, HTMLStencilElement {
    }
    var HTMLPostTabHeaderElement: {
        prototype: HTMLPostTabHeaderElement;
        new (): HTMLPostTabHeaderElement;
    };
    interface HTMLPostTabPanelElement extends Components.PostTabPanel, HTMLStencilElement {
    }
    var HTMLPostTabPanelElement: {
        prototype: HTMLPostTabPanelElement;
        new (): HTMLPostTabPanelElement;
    };
    interface HTMLPostTabsElementEventMap {
        "postChange": string;
    }
    interface HTMLPostTabsElement extends Components.PostTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostTabsElementEventMap>(type: K, listener: (this: HTMLPostTabsElement, ev: PostTabsCustomEvent<HTMLPostTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostTabsElementEventMap>(type: K, listener: (this: HTMLPostTabsElement, ev: PostTabsCustomEvent<HTMLPostTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostTabsElement: {
        prototype: HTMLPostTabsElement;
        new (): HTMLPostTabsElement;
    };
    interface HTMLPostTogglebuttonElement extends Components.PostTogglebutton, HTMLStencilElement {
    }
    var HTMLPostTogglebuttonElement: {
        prototype: HTMLPostTogglebuttonElement;
        new (): HTMLPostTogglebuttonElement;
    };
    interface HTMLPostTooltipElement extends Components.PostTooltip, HTMLStencilElement {
    }
    var HTMLPostTooltipElement: {
        prototype: HTMLPostTooltipElement;
        new (): HTMLPostTooltipElement;
    };
    interface HTMLPostTooltipTriggerElement extends Components.PostTooltipTrigger, HTMLStencilElement {
    }
    var HTMLPostTooltipTriggerElement: {
        prototype: HTMLPostTooltipTriggerElement;
        new (): HTMLPostTooltipTriggerElement;
    };
    interface HTMLElementTagNameMap {
        "post-accordion": HTMLPostAccordionElement;
        "post-accordion-item": HTMLPostAccordionItemElement;
        "post-avatar": HTMLPostAvatarElement;
        "post-back-to-top": HTMLPostBackToTopElement;
        "post-banner": HTMLPostBannerElement;
        "post-breadcrumb-item": HTMLPostBreadcrumbItemElement;
        "post-breadcrumbs": HTMLPostBreadcrumbsElement;
        "post-card-control": HTMLPostCardControlElement;
        "post-closebutton": HTMLPostClosebuttonElement;
        "post-collapsible": HTMLPostCollapsibleElement;
        "post-collapsible-trigger": HTMLPostCollapsibleTriggerElement;
        "post-footer": HTMLPostFooterElement;
        "post-header": HTMLPostHeaderElement;
        "post-icon": HTMLPostIconElement;
        "post-language-option": HTMLPostLanguageOptionElement;
        "post-language-switch": HTMLPostLanguageSwitchElement;
        "post-linkarea": HTMLPostLinkareaElement;
        "post-list": HTMLPostListElement;
        "post-list-item": HTMLPostListItemElement;
        "post-logo": HTMLPostLogoElement;
        "post-mainnavigation": HTMLPostMainnavigationElement;
        "post-megadropdown": HTMLPostMegadropdownElement;
        "post-megadropdown-trigger": HTMLPostMegadropdownTriggerElement;
        "post-menu": HTMLPostMenuElement;
        "post-menu-item": HTMLPostMenuItemElement;
        "post-menu-trigger": HTMLPostMenuTriggerElement;
        "post-popover": HTMLPostPopoverElement;
        "post-popovercontainer": HTMLPostPopovercontainerElement;
        "post-rating": HTMLPostRatingElement;
        "post-slider": HTMLPostSliderElement;
        "post-tab-header": HTMLPostTabHeaderElement;
        "post-tab-panel": HTMLPostTabPanelElement;
        "post-tabs": HTMLPostTabsElement;
        "post-togglebutton": HTMLPostTogglebuttonElement;
        "post-tooltip": HTMLPostTooltipElement;
        "post-tooltip-trigger": HTMLPostTooltipTriggerElement;
    }
}
declare namespace LocalJSX {
    interface PostAccordion {
        /**
          * Defines the hierarchical level of the `post-accordion-item` headers within the headings structure.
         */
        "headingLevel": HeadingLevel;
        /**
          * If `true`, multiple `post-accordion-item` can be open at the same time.
          * @default false
         */
        "multiple"?: boolean;
    }
    interface PostAccordionItem {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * Defines the hierarchical level of the accordion item header within the headings structure.
          * @deprecated set the `heading-level` property on the parent `post-accordion` instead.
         */
        "headingLevel"?: HeadingLevel;
    }
    interface PostAvatar {
        /**
          * Provides a custom description for the avatar, used for accessibility purposes.
         */
        "description"?: string;
        /**
          * Defines the users email address associated with a gravatar profile picture.
         */
        "email"?: string;
        /**
          * Defines the users firstname.
         */
        "firstname": string;
        /**
          * Defines the users lastname.
         */
        "lastname"?: string;
        /**
          * Defines the company internal userId.<post-banner type="warning" data-size="sm"><p>Can only be used on post.ch domains!</p></post-banner>
         */
        "userid"?: string;
    }
    interface PostBackToTop {
        /**
          * The label of the back-to-top button, intended solely for accessibility purposes. This label is always hidden from view.
         */
        "label": string;
    }
    interface PostBanner {
        /**
          * An event emitted when the banner element is dismissed, after the transition. It has no payload and only relevant for dismissible banners.
         */
        "onPostDismissed"?: (event: PostBannerCustomEvent<void>) => void;
        /**
          * The type of the banner.
          * @default 'info'
         */
        "type"?: BannerType;
    }
    interface PostBreadcrumbItem {
        /**
          * The optional URL to which the breadcrumb item will link.
         */
        "url"?: string | URL;
    }
    interface PostBreadcrumbs {
        /**
          * The text label for the home breadcrumb item.
          * @default 'Home'
         */
        "homeText"?: string;
        /**
          * The URL for the home breadcrumb item.
         */
        "homeUrl": string;
    }
    /**
     * @class PostCardControl - representing a stencil component
     */
    interface PostCardControl {
        /**
          * Defines the `checked` attribute of the control. If `true`, the control is selected at its value will be included in the forms' data.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Defines the description in the control-label.
         */
        "description"?: string;
        /**
          * Defines the `disabled` attribute of the control. If `true`, the user can not interact with the control and the controls value will not be included in the forms' data.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Defines the icon `name` inside the card. <post-banner data-size="sm"><p>If not set the icon will not show up.</p></post-banner>
         */
        "icon"?: string;
        /**
          * Defines the text in the control-label.
         */
        "label": string;
        /**
          * Defines the `name` attribute of the control. <post-banner data-size="sm"><p>This is a required property, when the control should participate in a native `form`. If not specified, a native `form` will never contain this controls value.</p></post-banner> <post-banner data-size="sm"><p>This is a required property, when the control is used with type `radio`.</p></post-banner>
         */
        "name"?: string;
        /**
          * An event emitted whenever the components checked state is toggled. The event payload (emitted under `event.detail.state`) is a boolean: `true` if the component is checked, `false` if it is unchecked. <post-banner data-size="sm"><p>If the component is used with type `radio`, it will only emit this event, when the checked state is changing to `true`.</p></post-banner>
         */
        "onPostChange"?: (event: PostCardControlCustomEvent<{ state: boolean; value: string }>) => void;
        /**
          * An event emitted whenever the components checked state is toggled. The event payload (emitted under `event.detail.state`) is a boolean: `true` if the component is checked, `false` if it is unchecked.
         */
        "onPostInput"?: (event: PostCardControlCustomEvent<{ state: boolean; value: string }>) => void;
        /**
          * Defines the `type` attribute of the control.
         */
        "type": 'checkbox' | 'radio';
        /**
          * Defines the validation `validity` of the control. To reset validity to an undefined state, simply remove the attribute from the control.
         */
        "validity"?: boolean;
        /**
          * Defines the `value` attribute of the control. <post-banner data-size="sm"><p>This is a required property, when the control is used with type `radio`.</p></post-banner>
         */
        "value"?: string;
    }
    interface PostClosebutton {
    }
    interface PostCollapsible {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
          * @default false
         */
        "collapsed"?: boolean;
        /**
          * An event emitted when the collapse element is shown or hidden, before the transition.  The event payload is a boolean: `true` if the collapsible was opened, `false` if it was closed.
         */
        "onPostToggle"?: (event: PostCollapsibleCustomEvent<boolean>) => void;
    }
    interface PostCollapsibleTrigger {
        /**
          * Link the trigger to a post-collapsible with this id
         */
        "for": string;
    }
    interface PostFooter {
        /**
          * The label to add to the footer (visually hidden).
         */
        "label": string;
    }
    interface PostHeader {
    }
    /**
     * @class PostIcon - representing a stencil component
     */
    interface PostIcon {
        /**
          * The name of the animation.
         */
        "animation"?: Animation;
        /**
          * The base path, where the icons are located (must be a public url).<br/>Leave this field empty to use the default cdn url.
         */
        "base"?: string;
        /**
          * When set to `true`, the icon will be flipped horizontally.
          * @default false
         */
        "flipH"?: boolean;
        /**
          * When set to `true`, the icon will be flipped vertically.
          * @default false
         */
        "flipV"?: boolean;
        /**
          * The name/id of the icon (e.g. 1000, 1001, ...).
         */
        "name": string;
        /**
          * The number of degree for the css rotate transformation.
         */
        "rotate"?: number;
        /**
          * The number for the css scale transformation.
         */
        "scale"?: number;
    }
    interface PostLanguageOption {
        /**
          * If set to `true`, the language option is considered the current language for the page.
         */
        "active"?: boolean;
        /**
          * The ISO 639 language code, formatted according to [RFC 5646 (also known as BCP 47)](https://datatracker.ietf.org/doc/html/rfc5646). For example, "de".
         */
        "code": string;
        /**
          * The full name of the language. For example, "Deutsch".
         */
        "name"?: string;
        /**
          * An event emitted when the language option is clicked. The payload is the ISO 639 code of the language.
         */
        "onPostChange"?: (event: PostLanguageOptionCustomEvent<string>) => void;
        /**
          * An event emitted when the language option is initially active. The payload is the ISO 639 code of the language.
         */
        "onPostLanguageOptionInitiallyActive"?: (event: PostLanguageOptionCustomEvent<string>) => void;
        /**
          * The URL used for the href attribute of the internal anchor. This field is optional; if not provided, a button will be used internally instead of an anchor.
         */
        "url"?: string;
        /**
          * To communicate the variant prop from the parent (post-language-switch) component to the child (post-language-option) component. See parent docs for a description about the property itself.
         */
        "variant"?: SwitchVariant;
    }
    interface PostLanguageSwitch {
        /**
          * A title for the list of language options
         */
        "caption": string;
        /**
          * A descriptive text for the list of language options
         */
        "description": string;
        /**
          * Whether the component is rendered as a list or a menu
          * @default 'list'
         */
        "variant"?: SwitchVariant;
    }
    interface PostLinkarea {
    }
    interface PostList {
        /**
          * The list can become horizontal by setting `horizontal="true"` or just `horizontal`
          * @default false
         */
        "horizontal"?: boolean;
        /**
          * If `true`, the list title will be hidden. Otherwise, it will be displayed.`
          * @default false
         */
        "titleHidden"?: boolean;
    }
    interface PostListItem {
    }
    interface PostLogo {
        /**
          * The URL to which the user is redirected upon clicking the logo.
         */
        "url"?: string | URL;
    }
    interface PostMainnavigation {
    }
    interface PostMegadropdown {
        /**
          * Emits when the dropdown is shown or hidden. The event payload is an object. `isVisible` is true when the dropdown gets opened and false when it gets closed `focusParent` determines whether after the closing of the mega dropdown, the focus should go back to the trigger parent or naturally go to the next focusable element in the page
         */
        "onPostToggleMegadropdown"?: (event: PostMegadropdownCustomEvent<{ isVisible: boolean; focusParent?: boolean }>) => void;
    }
    interface PostMegadropdownTrigger {
        /**
          * ID of the mega dropdown element that this trigger is linked to. Used to open and close the specified mega dropdown.
         */
        "for": string;
    }
    interface PostMenu {
        /**
          * An accessible name for the menu.
         */
        "label"?: string;
        /**
          * Emits when the menu is shown or hidden. The event payload is a boolean: `true` when the menu was opened, `false` when it was closed.
         */
        "onToggleMenu"?: (event: PostMenuCustomEvent<boolean>) => void;
        /**
          * Defines the position of the menu relative to its trigger. Menus are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries. For supported values and behavior details, see the [Floating UI placement documentation](https://floating-ui.com/docs/computePosition#placement).
          * @default 'bottom'
         */
        "placement"?: Placement;
    }
    interface PostMenuItem {
    }
    interface PostMenuTrigger {
        /**
          * ID of the menu element that this trigger is linked to. Used to open and close the specified menu.
         */
        "for": string;
    }
    interface PostPopover {
        /**
          * Show a little indicator arrow
          * @default true
         */
        "arrow"?: boolean;
        /**
          * Define the caption of the close button for assistive technology
         */
        "closeButtonCaption": string;
        /**
          * Defines the position of the popover relative to its trigger. Popovers are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries. For supported values and behavior details, see the [Floating UI placement documentation](https://floating-ui.com/docs/computePosition#placement).
          * @default 'top'
         */
        "placement"?: Placement;
    }
    interface PostPopovercontainer {
        /**
          * Animation style
          * @default null
         */
        "animation"?: 'pop-in' | null;
        /**
          * Whether or not to display a little pointer arrow
          * @default false
         */
        "arrow"?: boolean;
        /**
          * Gap between the edge of the page and the popovercontainer
          * @default 8
         */
        "edgeGap"?: number;
        /**
          * Whether or not the popovercontainer should close when user clicks outside of it
          * @default false
         */
        "manualClose"?: boolean;
        /**
          * Fires whenever the popovercontainer gets shown or hidden, passing in event.detail an object containing two booleans: `isOpen`, which is true if the popovercontainer was opened and false if it was closed, and `first`, which is true if it was opened for the first time.
         */
        "onPostToggle"?: (event: PostPopovercontainerCustomEvent<{ isOpen: boolean; first?: boolean }>) => void;
        /**
          * Defines the placement of the popovercontainer according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Popovercontainers are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
          * @default 'top'
         */
        "placement"?: Placement;
        /**
          * Enables a safespace through which the cursor can be moved without the popover being disabled
         */
        "safeSpace"?: 'triangle' | 'trapezoid';
    }
    interface PostRating {
        /**
          * Defines the rating that the component should show.
          * @default 0
         */
        "currentRating"?: number;
        /**
          * Defines a hidden label for the component.
          * @default 'Rating'
         */
        "label"?: string;
        /**
          * An event emitted whenever the component's value has changed (on blur). The event payload can be used like so: `event.detail.value`.
         */
        "onPostChange"?: (event: PostRatingCustomEvent<{ value: number }>) => void;
        /**
          * An event emitted whenever the component's value has changed (on input). The event payload can be used like so: `event.detail.value`.
         */
        "onPostInput"?: (event: PostRatingCustomEvent<{ value: number }>) => void;
        /**
          * Defines if the component is readonly or not. This usually should be used together with the `currentRating` property.
          * @default false
         */
        "readonly"?: boolean;
        /**
          * Defines the total amount of stars rendered in the component.
          * @default 5
         */
        "stars"?: number;
    }
    interface PostSlider {
        /**
          * The greatest value in the range of permitted values.
          * @default 100
         */
        "max"?: number;
        /**
          * The lowest value in the range of permitted values.
          * @default 0
         */
        "min"?: number;
        /**
          * Event dispatched when a thumb is released after sliding, payload is the current value.
         */
        "onPostChange"?: (event: PostSliderCustomEvent<number | [number, number]>) => void;
        /**
          * Event dispatched while a thumb is sliding, payload is the current value.
         */
        "onPostInput"?: (event: PostSliderCustomEvent<number | [number, number]>) => void;
        /**
          * The orientation of the slider: "horizontal" or "vertical".
          * @default 'horizontal'
         */
        "orient"?: Orientation;
        /**
          * If true, the slider has two thumbs allowing for range selection.
          * @default false
         */
        "range"?: boolean;
        /**
          * The granularity that the value must adhere to.
          * @default 1
         */
        "step"?: number | 'any';
        /**
          * The number or range initially selected.
         */
        "value"?: number | [number, number];
    }
    interface PostTabHeader {
        /**
          * The name of the panel controlled by the tab header.
         */
        "panel": string;
    }
    interface PostTabPanel {
        /**
          * The name of the panel, used to associate it with a tab header.
         */
        "name": string;
    }
    interface PostTabs {
        /**
          * The name of the panel that is initially shown. If not specified, it defaults to the panel associated with the first tab.  **Changing this value after initialization has no effect.**
         */
        "activePanel"?: HTMLPostTabPanelElement['name'];
        /**
          * When set to true, this property allows the tabs container to span the full width of the screen, from edge to edge.
          * @default false
         */
        "fullWidth"?: boolean;
        /**
          * An event emitted after the active tab changes, when the fade in transition of its associated panel is finished. The payload is the name of the newly shown panel.
         */
        "onPostChange"?: (event: PostTabsCustomEvent<string>) => void;
    }
    interface PostTogglebutton {
        /**
          * If `true`, the button is in the "on" state, otherwise it is in the "off" state.
          * @default false
         */
        "toggled"?: boolean;
    }
    interface PostTooltip {
        /**
          * Choose a tooltip animation
         */
        "animation"?: 'pop-in';
        /**
          * Whether or not to display a little pointer arrow
          * @default false
         */
        "arrow"?: boolean;
        /**
          * Indicates the open state of the tooltip
          * @default false
         */
        "open"?: boolean;
        /**
          * Defines the position of the tooltip relative to its trigger. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries. For supported values and behavior details, see the [Floating UI placement documentation](https://floating-ui.com/docs/computePosition#placement).
          * @default 'top'
         */
        "placement"?: Placement;
    }
    interface PostTooltipTrigger {
        /**
          * Delay (in milliseconds) before the tooltip is shown.
          * @default 0
         */
        "delay"?: number;
        /**
          * ID of the tooltip element that this trigger is linked to.
         */
        "for": string;
    }
    interface IntrinsicElements {
        "post-accordion": PostAccordion;
        "post-accordion-item": PostAccordionItem;
        "post-avatar": PostAvatar;
        "post-back-to-top": PostBackToTop;
        "post-banner": PostBanner;
        "post-breadcrumb-item": PostBreadcrumbItem;
        "post-breadcrumbs": PostBreadcrumbs;
        "post-card-control": PostCardControl;
        "post-closebutton": PostClosebutton;
        "post-collapsible": PostCollapsible;
        "post-collapsible-trigger": PostCollapsibleTrigger;
        "post-footer": PostFooter;
        "post-header": PostHeader;
        "post-icon": PostIcon;
        "post-language-option": PostLanguageOption;
        "post-language-switch": PostLanguageSwitch;
        "post-linkarea": PostLinkarea;
        "post-list": PostList;
        "post-list-item": PostListItem;
        "post-logo": PostLogo;
        "post-mainnavigation": PostMainnavigation;
        "post-megadropdown": PostMegadropdown;
        "post-megadropdown-trigger": PostMegadropdownTrigger;
        "post-menu": PostMenu;
        "post-menu-item": PostMenuItem;
        "post-menu-trigger": PostMenuTrigger;
        "post-popover": PostPopover;
        "post-popovercontainer": PostPopovercontainer;
        "post-rating": PostRating;
        "post-slider": PostSlider;
        "post-tab-header": PostTabHeader;
        "post-tab-panel": PostTabPanel;
        "post-tabs": PostTabs;
        "post-togglebutton": PostTogglebutton;
        "post-tooltip": PostTooltip;
        "post-tooltip-trigger": PostTooltipTrigger;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "post-accordion": LocalJSX.PostAccordion & JSXBase.HTMLAttributes<HTMLPostAccordionElement>;
            "post-accordion-item": LocalJSX.PostAccordionItem & JSXBase.HTMLAttributes<HTMLPostAccordionItemElement>;
            "post-avatar": LocalJSX.PostAvatar & JSXBase.HTMLAttributes<HTMLPostAvatarElement>;
            "post-back-to-top": LocalJSX.PostBackToTop & JSXBase.HTMLAttributes<HTMLPostBackToTopElement>;
            "post-banner": LocalJSX.PostBanner & JSXBase.HTMLAttributes<HTMLPostBannerElement>;
            "post-breadcrumb-item": LocalJSX.PostBreadcrumbItem & JSXBase.HTMLAttributes<HTMLPostBreadcrumbItemElement>;
            "post-breadcrumbs": LocalJSX.PostBreadcrumbs & JSXBase.HTMLAttributes<HTMLPostBreadcrumbsElement>;
            /**
             * @class PostCardControl - representing a stencil component
             */
            "post-card-control": LocalJSX.PostCardControl & JSXBase.HTMLAttributes<HTMLPostCardControlElement>;
            "post-closebutton": LocalJSX.PostClosebutton & JSXBase.HTMLAttributes<HTMLPostClosebuttonElement>;
            "post-collapsible": LocalJSX.PostCollapsible & JSXBase.HTMLAttributes<HTMLPostCollapsibleElement>;
            "post-collapsible-trigger": LocalJSX.PostCollapsibleTrigger & JSXBase.HTMLAttributes<HTMLPostCollapsibleTriggerElement>;
            "post-footer": LocalJSX.PostFooter & JSXBase.HTMLAttributes<HTMLPostFooterElement>;
            "post-header": LocalJSX.PostHeader & JSXBase.HTMLAttributes<HTMLPostHeaderElement>;
            /**
             * @class PostIcon - representing a stencil component
             */
            "post-icon": LocalJSX.PostIcon & JSXBase.HTMLAttributes<HTMLPostIconElement>;
            "post-language-option": LocalJSX.PostLanguageOption & JSXBase.HTMLAttributes<HTMLPostLanguageOptionElement>;
            "post-language-switch": LocalJSX.PostLanguageSwitch & JSXBase.HTMLAttributes<HTMLPostLanguageSwitchElement>;
            "post-linkarea": LocalJSX.PostLinkarea & JSXBase.HTMLAttributes<HTMLPostLinkareaElement>;
            "post-list": LocalJSX.PostList & JSXBase.HTMLAttributes<HTMLPostListElement>;
            "post-list-item": LocalJSX.PostListItem & JSXBase.HTMLAttributes<HTMLPostListItemElement>;
            "post-logo": LocalJSX.PostLogo & JSXBase.HTMLAttributes<HTMLPostLogoElement>;
            "post-mainnavigation": LocalJSX.PostMainnavigation & JSXBase.HTMLAttributes<HTMLPostMainnavigationElement>;
            "post-megadropdown": LocalJSX.PostMegadropdown & JSXBase.HTMLAttributes<HTMLPostMegadropdownElement>;
            "post-megadropdown-trigger": LocalJSX.PostMegadropdownTrigger & JSXBase.HTMLAttributes<HTMLPostMegadropdownTriggerElement>;
            "post-menu": LocalJSX.PostMenu & JSXBase.HTMLAttributes<HTMLPostMenuElement>;
            "post-menu-item": LocalJSX.PostMenuItem & JSXBase.HTMLAttributes<HTMLPostMenuItemElement>;
            "post-menu-trigger": LocalJSX.PostMenuTrigger & JSXBase.HTMLAttributes<HTMLPostMenuTriggerElement>;
            "post-popover": LocalJSX.PostPopover & JSXBase.HTMLAttributes<HTMLPostPopoverElement>;
            "post-popovercontainer": LocalJSX.PostPopovercontainer & JSXBase.HTMLAttributes<HTMLPostPopovercontainerElement>;
            "post-rating": LocalJSX.PostRating & JSXBase.HTMLAttributes<HTMLPostRatingElement>;
            "post-slider": LocalJSX.PostSlider & JSXBase.HTMLAttributes<HTMLPostSliderElement>;
            "post-tab-header": LocalJSX.PostTabHeader & JSXBase.HTMLAttributes<HTMLPostTabHeaderElement>;
            "post-tab-panel": LocalJSX.PostTabPanel & JSXBase.HTMLAttributes<HTMLPostTabPanelElement>;
            "post-tabs": LocalJSX.PostTabs & JSXBase.HTMLAttributes<HTMLPostTabsElement>;
            "post-togglebutton": LocalJSX.PostTogglebutton & JSXBase.HTMLAttributes<HTMLPostTogglebuttonElement>;
            "post-tooltip": LocalJSX.PostTooltip & JSXBase.HTMLAttributes<HTMLPostTooltipElement>;
            "post-tooltip-trigger": LocalJSX.PostTooltipTrigger & JSXBase.HTMLAttributes<HTMLPostTooltipTriggerElement>;
        }
    }
}
