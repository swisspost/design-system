/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { HeadingLevel } from "./types/index";
import { BannerType } from "./components/post-banner/banner-types";
import { DEVICE_SIZE } from "./components/post-header/post-header";
import { SwitchVariant } from "./components/post-language-switch/switch-variants";
import { Placement } from "@floating-ui/dom";
export { HeadingLevel } from "./types/index";
export { BannerType } from "./components/post-banner/banner-types";
export { DEVICE_SIZE } from "./components/post-header/post-header";
export { SwitchVariant } from "./components/post-language-switch/switch-variants";
export { Placement } from "@floating-ui/dom";
export namespace Components {
    interface PostAccordion {
        /**
          * Collapses all `post-accordion-item`.
         */
        "collapseAll": () => Promise<void>;
        /**
          * Expands all `post-accordion-item`.  If `multiple="true"` is not set and all items are closed, it will open the first one. Otherwise, it will keep the opened one.
         */
        "expandAll": () => Promise<void>;
        /**
          * Defines the hierarchical level of the `post-accordion-item` headers within the headings structure.
         */
        "headingLevel": HeadingLevel;
        /**
          * If `true`, multiple `post-accordion-item` can be open at the same time.
         */
        "multiple": boolean;
        /**
          * Toggles the `post-accordion-item` with the given id.
         */
        "toggle": (id: string) => Promise<void>;
    }
    interface PostAccordionItem {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
         */
        "collapsed"?: boolean;
        /**
          * Defines the hierarchical level of the accordion item header within the headings structure.
          * @deprecated set the `heading-level` property on the parent `post-accordion` instead.
         */
        "headingLevel"?: HeadingLevel;
        /**
          * Triggers the collapse programmatically.
         */
        "toggle": (force?: boolean) => Promise<boolean>;
    }
    interface PostAvatar {
        /**
          * Defines the users email address associated with a gravatar profile picture.
         */
        "email"?: string;
        /**
          * Defines the users firstname.
         */
        "firstname": string;
        /**
          * Defines the users lastname.
         */
        "lastname"?: string;
        /**
          * Defines the company internal userId.<div className="mb-1 banner banner-warning banner-sm">Can only be used on post.ch domains!</div>
         */
        "userid"?: string;
    }
    interface PostBackToTop {
        /**
          * The label of the back-to-top button, intended solely for accessibility purposes. This label is always hidden from view.
         */
        "label": string;
    }
    interface PostBanner {
        /**
          * Triggers banner dismissal programmatically (same as clicking on the close button (×)).
         */
        "dismiss": () => Promise<void>;
        /**
          * The label to use for the close button of a dismissible banner.
         */
        "dismissLabel": string;
        /**
          * If `true`, a close button (×) is displayed and the banner can be dismissed by the user.
         */
        "dismissible": boolean;
        /**
          * The icon to display in the banner. By default, the icon depends on the banner type.  If `none`, no icon is displayed.
         */
        "icon": string;
        /**
          * The type of the banner.
         */
        "type": BannerType;
    }
    interface PostBreadcrumb {
        /**
          * The text label for the home breadcrumb item.
         */
        "homeText": string;
        /**
          * The URL for the home breadcrumb item.
         */
        "homeUrl": string;
    }
    interface PostBreadcrumbItem {
        /**
          * The optional URL to which the breadcrumb item will link.
         */
        "url"?: string | URL;
    }
    /**
     * @class PostCardControl - representing a stencil component
     */
    interface PostCardControl {
        /**
          * Defines the `checked` attribute of the control. If `true`, the control is selected at its value will be included in the forms' data.
         */
        "checked": boolean;
        /**
          * Defines the description in the control-label.
         */
        "description": string;
        /**
          * Defines the `disabled` attribute of the control. If `true`, the user can not interact with the control and the controls value will not be included in the forms' data.
         */
        "disabled": boolean;
        /**
          * A hidden public method to reset the group controls `checked` state to `false`.
         */
        "groupReset": () => Promise<void>;
        /**
          * Defines the icon `name` inside the card. <span className="banner banner-sm banner-info">If not set the icon will not show up.</span>
         */
        "icon": string;
        /**
          * Defines the text in the control-label.
         */
        "label": string;
        /**
          * Defines the `name` attribute of the control. <span className="banner banner-sm banner-info">This is a required property, when the control should participate in a native `form`. If not specified, a native `form` will never contain this controls value.</span> <span className="banner banner-sm banner-info">This is a required property, when the control is used with type `radio`.</span>
         */
        "name": string;
        /**
          * A public method to reset the controls `checked` and `validity` state. The validity state is set to `null`, so it's neither valid nor invalid.
         */
        "reset": () => Promise<void>;
        /**
          * Defines the `type` attribute of the control.
         */
        "type": 'checkbox' | 'radio';
        /**
          * Defines the validation `validity` of the control. To reset validity to an undefined state, simply remove the attribute from the control.
         */
        "validity": null | 'true' | 'false';
        /**
          * Defines the `value` attribute of the control. <span className="banner banner-sm banner-info">This is a required property, when the control is used with type `radio`.</span>
         */
        "value": string;
    }
    interface PostClosebutton {
    }
    interface PostCollapsible {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
         */
        "collapsed"?: boolean;
        /**
          * Triggers the collapse programmatically.  If there is a collapsing transition running already, it will be reversed.
         */
        "toggle": (open?: boolean) => Promise<boolean>;
    }
    interface PostCollapsibleTrigger {
        /**
          * Link the trigger to a post-collapsible with this id
         */
        "for": string;
        /**
          * Update the "aria-controls" and "aria-expanded" attributes on the trigger button
         */
        "update": () => Promise<void>;
    }
    interface PostFooter {
        /**
          * The label to add to the footer (visually hidden).
         */
        "label": string;
    }
    interface PostHeader {
        /**
          * Toggles the mobile navigation.
         */
        "toggleMobileMenu": (force?: boolean) => Promise<void>;
    }
    /**
     * @class PostIcon - representing a stencil component
     */
    interface PostIcon {
        /**
          * The name of the animation.
         */
        "animation"?: Animation | null;
        /**
          * The base path, where the icons are located (must be a public url).<br/>Leave this field empty to use the default cdn url.
         */
        "base"?: string | null;
        /**
          * When set to `true`, the icon will be flipped horizontally.
         */
        "flipH"?: boolean;
        /**
          * When set to `true`, the icon will be flipped vertically.
         */
        "flipV"?: boolean;
        /**
          * The name/id of the icon (e.g. 1000, 1001, ...).
         */
        "name": string;
        /**
          * The number of degree for the css rotate transformation.
         */
        "rotate"?: number | null;
        /**
          * The number for the css scale transformation.
         */
        "scale"?: number | null;
    }
    interface PostLanguageOption {
        /**
          * If set to `true`, the language option is considered the current language for the page.
         */
        "active": boolean;
        /**
          * The ISO 639 language code, formatted according to [RFC 5646 (also known as BCP 47)](https://datatracker.ietf.org/doc/html/rfc5646). For example, "de".
         */
        "code": string;
        /**
          * The full name of the language. For example, "Deutsch".
         */
        "name": string;
        /**
          * Selects the language option programmatically.
         */
        "select": () => Promise<void>;
        /**
          * The URL used for the href attribute of the internal anchor. This field is optional; if not provided, a button will be used internally instead of an anchor.
         */
        "url": string;
        /**
          * To communicate the variant prop from the parent (post-language-switch) component to the child (post-language-option) component. See parent docs for a description about the property itself.
         */
        "variant"?: SwitchVariant | null;
    }
    interface PostLanguageSwitch {
        /**
          * A title for the list of language options
         */
        "caption": string;
        /**
          * A descriptive text for the list of language options
         */
        "description": string;
        /**
          * Whether the component is rendered as a list or a menu
         */
        "variant": SwitchVariant;
    }
    interface PostLinkarea {
    }
    interface PostList {
        /**
          * The list can become horizontal by setting `horizontal="true"` or just `horizontal`
         */
        "horizontal": boolean;
        /**
          * If `true`, the list title will be hidden. Otherwise, it will be displayed.`
         */
        "titleHidden": boolean;
    }
    interface PostListItem {
    }
    interface PostLogo {
        /**
          * The URL to which the user is redirected upon clicking the logo.
         */
        "url": string | URL;
    }
    interface PostMainnavigation {
    }
    interface PostMegadropdown {
        /**
          * Sets focus to the first focusable element within the component.
         */
        "focusFirst": () => Promise<void>;
        /**
          * Hides the dropdown with an animation.
         */
        "hide": (focusParent?: boolean, forceClose?: boolean) => Promise<void>;
        /**
          * Displays the dropdown.
         */
        "show": () => Promise<void>;
        /**
          * Toggles the dropdown visibility based on its current state.
         */
        "toggle": () => Promise<void>;
    }
    interface PostMegadropdownTrigger {
        /**
          * ID of the mega dropdown element that this trigger is linked to. Used to open and close the specified mega dropdown.
         */
        "for": string;
    }
    interface PostMenu {
        /**
          * Hides the popover menu and restores focus to the previously focused element.
         */
        "hide": () => Promise<void>;
        /**
          * Defines the placement of the tooltip according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
        /**
          * Displays the popover menu, focusing the first menu item.
          * @param target - The HTML element relative to which the popover menu should be displayed.
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggles the menu visibility based on its current state.
         */
        "toggle": (target: HTMLElement) => Promise<void>;
    }
    interface PostMenuItem {
    }
    interface PostMenuTrigger {
        /**
          * ID of the menu element that this trigger is linked to. Used to open and close the specified menu.
         */
        "for": string;
    }
    interface PostPopover {
        /**
          * Show a little indicator arrow
         */
        "arrow"?: boolean;
        /**
          * Define the caption of the close button for assistive technology
         */
        "closeButtonCaption": string;
        /**
          * Programmatically hide this popover
         */
        "hide": () => Promise<void>;
        /**
          * Defines the placement of the popover according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Popoverss are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
        /**
          * Programmatically display the popover
          * @param target An element with [data-popover-target="id"] where the popover should be shown
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggle popover display
          * @param target An element with [data-popover-target="id"] where the popover should be anchored to
          * @param force Pass true to always show or false to always hide
         */
        "toggle": (target: HTMLElement, force?: boolean) => Promise<void>;
    }
    interface PostPopovercontainer {
        /**
          * Whether or not to display a little pointer arrow
         */
        "arrow"?: boolean;
        /**
          * Gap between the edge of the page and the popover
         */
        "edgeGap"?: number;
        /**
          * Programmatically hide this tooltip
         */
        "hide": () => Promise<void>;
        /**
          * Whether or not the popover should close when user clicks outside of it
         */
        "manualClose": boolean;
        /**
          * Defines the placement of the tooltip according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
        /**
          * Enables a safespace through which the cursor can be moved without the popover being disabled
         */
        "safeSpace"?: 'triangle' | 'trapezoid';
        /**
          * Programmatically display the tooltip
          * @param target An element with [data-tooltip-target="id"] where the tooltip should be shown
         */
        "show": (target: HTMLElement) => Promise<void>;
        /**
          * Toggle tooltip display
          * @param target An element with [data-tooltip-target="id"] where the tooltip should be shown
          * @param force Pass true to always show or false to always hide
         */
        "toggle": (target: HTMLElement, force?: boolean) => Promise<boolean>;
    }
    interface PostRating {
        /**
          * Defines the rating that the component should show.
         */
        "currentRating": number;
        /**
          * Defines a hidden label for the component.
         */
        "label": string;
        /**
          * Defines if the component is readonly or not. This usually should be used together with the `currentRating` property.
         */
        "readonly": boolean;
        /**
          * Defines the total amount of stars rendered in the component.
         */
        "stars": number;
    }
    interface PostTabHeader {
        /**
          * The name of the panel controlled by the tab header.
         */
        "panel": HTMLPostTabPanelElement['name'];
    }
    interface PostTabPanel {
        /**
          * The name of the panel, used to associate it with a tab header.
         */
        "name": string;
    }
    interface PostTabs {
        /**
          * The name of the panel that is initially shown. If not specified, it defaults to the panel associated with the first tab.  **Changing this value after initialization has no effect.**
         */
        "activePanel": HTMLPostTabPanelElement['name'];
        /**
          * Shows the panel with the given name and selects its associated tab. Any other panel that was previously shown becomes hidden and its associated tab is unselected.
         */
        "show": (panelName: string) => Promise<void>;
    }
    interface PostTag {
        /**
          * Defines the icon `name` inside of the component. <span className="banner banner-sm banner-info">If not set the icon will not show up.</span> To learn which icons are available, please visit our <a href="/?path=/docs/5704bdc4-c5b5-45e6-b123-c54d01fce2f1--docs">icon library</a>.
         */
        "icon": null | string;
        /**
          * Defines the size of the component.
         */
        "size": null | 'sm';
        /**
          * Defines the color variant of the component.
         */
        "variant": 'white' | 'info' | 'success' | 'error' | 'warning' | 'yellow';
    }
    interface PostTogglebutton {
        /**
          * If `true`, the button is in the "on" state, otherwise it is in the "off" state.
         */
        "toggled": boolean;
    }
    interface PostTooltip {
        /**
          * Wheter or not to display a little pointer arrow
         */
        "arrow"?: boolean;
        /**
          * If `true`, the tooltip is displayed a few milliseconds after it is triggered
         */
        "delayed": boolean;
        /**
          * Programmatically hide this tooltip
         */
        "hide": () => Promise<void>;
        /**
          * Defines the placement of the tooltip according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
        /**
          * Programmatically display the tooltip
          * @param target An element with [data-tooltip-target="id"] where the tooltip should be shown
          * @param triggeredByFocus A boolean indicating if the tooltip was triggered by a focus event.
         */
        "show": (target: HTMLElement, triggeredByFocus?: boolean) => Promise<void>;
        /**
          * Toggle tooltip display
          * @param target An element with [data-tooltip-target="id"] where the tooltip should be shown
          * @param force Pass true to always show or false to always hide
         */
        "toggle": (target: HTMLElement, force?: boolean) => Promise<void>;
    }
}
export interface PostBannerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostBannerElement;
}
export interface PostCardControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostCardControlElement;
}
export interface PostCollapsibleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostCollapsibleElement;
}
export interface PostHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostHeaderElement;
}
export interface PostLanguageOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostLanguageOptionElement;
}
export interface PostMegadropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostMegadropdownElement;
}
export interface PostMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostMenuElement;
}
export interface PostPopovercontainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostPopovercontainerElement;
}
export interface PostRatingCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostRatingElement;
}
export interface PostTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPostTabsElement;
}
declare global {
    interface HTMLPostAccordionElement extends Components.PostAccordion, HTMLStencilElement {
    }
    var HTMLPostAccordionElement: {
        prototype: HTMLPostAccordionElement;
        new (): HTMLPostAccordionElement;
    };
    interface HTMLPostAccordionItemElement extends Components.PostAccordionItem, HTMLStencilElement {
    }
    var HTMLPostAccordionItemElement: {
        prototype: HTMLPostAccordionItemElement;
        new (): HTMLPostAccordionItemElement;
    };
    interface HTMLPostAvatarElement extends Components.PostAvatar, HTMLStencilElement {
    }
    var HTMLPostAvatarElement: {
        prototype: HTMLPostAvatarElement;
        new (): HTMLPostAvatarElement;
    };
    interface HTMLPostBackToTopElement extends Components.PostBackToTop, HTMLStencilElement {
    }
    var HTMLPostBackToTopElement: {
        prototype: HTMLPostBackToTopElement;
        new (): HTMLPostBackToTopElement;
    };
    interface HTMLPostBannerElementEventMap {
        "postDismissed": void;
    }
    interface HTMLPostBannerElement extends Components.PostBanner, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostBannerElementEventMap>(type: K, listener: (this: HTMLPostBannerElement, ev: PostBannerCustomEvent<HTMLPostBannerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostBannerElementEventMap>(type: K, listener: (this: HTMLPostBannerElement, ev: PostBannerCustomEvent<HTMLPostBannerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostBannerElement: {
        prototype: HTMLPostBannerElement;
        new (): HTMLPostBannerElement;
    };
    interface HTMLPostBreadcrumbElement extends Components.PostBreadcrumb, HTMLStencilElement {
    }
    var HTMLPostBreadcrumbElement: {
        prototype: HTMLPostBreadcrumbElement;
        new (): HTMLPostBreadcrumbElement;
    };
    interface HTMLPostBreadcrumbItemElement extends Components.PostBreadcrumbItem, HTMLStencilElement {
    }
    var HTMLPostBreadcrumbItemElement: {
        prototype: HTMLPostBreadcrumbItemElement;
        new (): HTMLPostBreadcrumbItemElement;
    };
    interface HTMLPostCardControlElementEventMap {
        "postInput": { state: boolean; value: string };
        "postChange": { state: boolean; value: string };
    }
    /**
     * @class PostCardControl - representing a stencil component
     */
    interface HTMLPostCardControlElement extends Components.PostCardControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostCardControlElementEventMap>(type: K, listener: (this: HTMLPostCardControlElement, ev: PostCardControlCustomEvent<HTMLPostCardControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostCardControlElementEventMap>(type: K, listener: (this: HTMLPostCardControlElement, ev: PostCardControlCustomEvent<HTMLPostCardControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostCardControlElement: {
        prototype: HTMLPostCardControlElement;
        new (): HTMLPostCardControlElement;
    };
    interface HTMLPostClosebuttonElement extends Components.PostClosebutton, HTMLStencilElement {
    }
    var HTMLPostClosebuttonElement: {
        prototype: HTMLPostClosebuttonElement;
        new (): HTMLPostClosebuttonElement;
    };
    interface HTMLPostCollapsibleElementEventMap {
        "postToggle": boolean;
    }
    interface HTMLPostCollapsibleElement extends Components.PostCollapsible, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostCollapsibleElementEventMap>(type: K, listener: (this: HTMLPostCollapsibleElement, ev: PostCollapsibleCustomEvent<HTMLPostCollapsibleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostCollapsibleElementEventMap>(type: K, listener: (this: HTMLPostCollapsibleElement, ev: PostCollapsibleCustomEvent<HTMLPostCollapsibleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostCollapsibleElement: {
        prototype: HTMLPostCollapsibleElement;
        new (): HTMLPostCollapsibleElement;
    };
    interface HTMLPostCollapsibleTriggerElement extends Components.PostCollapsibleTrigger, HTMLStencilElement {
    }
    var HTMLPostCollapsibleTriggerElement: {
        prototype: HTMLPostCollapsibleTriggerElement;
        new (): HTMLPostCollapsibleTriggerElement;
    };
    interface HTMLPostFooterElement extends Components.PostFooter, HTMLStencilElement {
    }
    var HTMLPostFooterElement: {
        prototype: HTMLPostFooterElement;
        new (): HTMLPostFooterElement;
    };
    interface HTMLPostHeaderElementEventMap {
        "postUpdateDevice": DEVICE_SIZE;
    }
    interface HTMLPostHeaderElement extends Components.PostHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostHeaderElementEventMap>(type: K, listener: (this: HTMLPostHeaderElement, ev: PostHeaderCustomEvent<HTMLPostHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostHeaderElementEventMap>(type: K, listener: (this: HTMLPostHeaderElement, ev: PostHeaderCustomEvent<HTMLPostHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostHeaderElement: {
        prototype: HTMLPostHeaderElement;
        new (): HTMLPostHeaderElement;
    };
    /**
     * @class PostIcon - representing a stencil component
     */
    interface HTMLPostIconElement extends Components.PostIcon, HTMLStencilElement {
    }
    var HTMLPostIconElement: {
        prototype: HTMLPostIconElement;
        new (): HTMLPostIconElement;
    };
    interface HTMLPostLanguageOptionElementEventMap {
        "postChange": string;
        "postLanguageOptionInitiallyActive": string;
    }
    interface HTMLPostLanguageOptionElement extends Components.PostLanguageOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostLanguageOptionElementEventMap>(type: K, listener: (this: HTMLPostLanguageOptionElement, ev: PostLanguageOptionCustomEvent<HTMLPostLanguageOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostLanguageOptionElementEventMap>(type: K, listener: (this: HTMLPostLanguageOptionElement, ev: PostLanguageOptionCustomEvent<HTMLPostLanguageOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostLanguageOptionElement: {
        prototype: HTMLPostLanguageOptionElement;
        new (): HTMLPostLanguageOptionElement;
    };
    interface HTMLPostLanguageSwitchElement extends Components.PostLanguageSwitch, HTMLStencilElement {
    }
    var HTMLPostLanguageSwitchElement: {
        prototype: HTMLPostLanguageSwitchElement;
        new (): HTMLPostLanguageSwitchElement;
    };
    interface HTMLPostLinkareaElement extends Components.PostLinkarea, HTMLStencilElement {
    }
    var HTMLPostLinkareaElement: {
        prototype: HTMLPostLinkareaElement;
        new (): HTMLPostLinkareaElement;
    };
    interface HTMLPostListElement extends Components.PostList, HTMLStencilElement {
    }
    var HTMLPostListElement: {
        prototype: HTMLPostListElement;
        new (): HTMLPostListElement;
    };
    interface HTMLPostListItemElement extends Components.PostListItem, HTMLStencilElement {
    }
    var HTMLPostListItemElement: {
        prototype: HTMLPostListItemElement;
        new (): HTMLPostListItemElement;
    };
    interface HTMLPostLogoElement extends Components.PostLogo, HTMLStencilElement {
    }
    var HTMLPostLogoElement: {
        prototype: HTMLPostLogoElement;
        new (): HTMLPostLogoElement;
    };
    interface HTMLPostMainnavigationElement extends Components.PostMainnavigation, HTMLStencilElement {
    }
    var HTMLPostMainnavigationElement: {
        prototype: HTMLPostMainnavigationElement;
        new (): HTMLPostMainnavigationElement;
    };
    interface HTMLPostMegadropdownElementEventMap {
        "postToggleMegadropdown": { isVisible: boolean; focusParent?: boolean };
    }
    interface HTMLPostMegadropdownElement extends Components.PostMegadropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostMegadropdownElementEventMap>(type: K, listener: (this: HTMLPostMegadropdownElement, ev: PostMegadropdownCustomEvent<HTMLPostMegadropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostMegadropdownElementEventMap>(type: K, listener: (this: HTMLPostMegadropdownElement, ev: PostMegadropdownCustomEvent<HTMLPostMegadropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostMegadropdownElement: {
        prototype: HTMLPostMegadropdownElement;
        new (): HTMLPostMegadropdownElement;
    };
    interface HTMLPostMegadropdownTriggerElement extends Components.PostMegadropdownTrigger, HTMLStencilElement {
    }
    var HTMLPostMegadropdownTriggerElement: {
        prototype: HTMLPostMegadropdownTriggerElement;
        new (): HTMLPostMegadropdownTriggerElement;
    };
    interface HTMLPostMenuElementEventMap {
        "toggleMenu": boolean;
    }
    interface HTMLPostMenuElement extends Components.PostMenu, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostMenuElementEventMap>(type: K, listener: (this: HTMLPostMenuElement, ev: PostMenuCustomEvent<HTMLPostMenuElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostMenuElementEventMap>(type: K, listener: (this: HTMLPostMenuElement, ev: PostMenuCustomEvent<HTMLPostMenuElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostMenuElement: {
        prototype: HTMLPostMenuElement;
        new (): HTMLPostMenuElement;
    };
    interface HTMLPostMenuItemElement extends Components.PostMenuItem, HTMLStencilElement {
    }
    var HTMLPostMenuItemElement: {
        prototype: HTMLPostMenuItemElement;
        new (): HTMLPostMenuItemElement;
    };
    interface HTMLPostMenuTriggerElement extends Components.PostMenuTrigger, HTMLStencilElement {
    }
    var HTMLPostMenuTriggerElement: {
        prototype: HTMLPostMenuTriggerElement;
        new (): HTMLPostMenuTriggerElement;
    };
    interface HTMLPostPopoverElement extends Components.PostPopover, HTMLStencilElement {
    }
    var HTMLPostPopoverElement: {
        prototype: HTMLPostPopoverElement;
        new (): HTMLPostPopoverElement;
    };
    interface HTMLPostPopovercontainerElementEventMap {
        "postToggle": boolean;
    }
    interface HTMLPostPopovercontainerElement extends Components.PostPopovercontainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostPopovercontainerElementEventMap>(type: K, listener: (this: HTMLPostPopovercontainerElement, ev: PostPopovercontainerCustomEvent<HTMLPostPopovercontainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostPopovercontainerElementEventMap>(type: K, listener: (this: HTMLPostPopovercontainerElement, ev: PostPopovercontainerCustomEvent<HTMLPostPopovercontainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostPopovercontainerElement: {
        prototype: HTMLPostPopovercontainerElement;
        new (): HTMLPostPopovercontainerElement;
    };
    interface HTMLPostRatingElementEventMap {
        "postInput": { value: number };
        "postChange": { value: number };
    }
    interface HTMLPostRatingElement extends Components.PostRating, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostRatingElementEventMap>(type: K, listener: (this: HTMLPostRatingElement, ev: PostRatingCustomEvent<HTMLPostRatingElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostRatingElementEventMap>(type: K, listener: (this: HTMLPostRatingElement, ev: PostRatingCustomEvent<HTMLPostRatingElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostRatingElement: {
        prototype: HTMLPostRatingElement;
        new (): HTMLPostRatingElement;
    };
    interface HTMLPostTabHeaderElement extends Components.PostTabHeader, HTMLStencilElement {
    }
    var HTMLPostTabHeaderElement: {
        prototype: HTMLPostTabHeaderElement;
        new (): HTMLPostTabHeaderElement;
    };
    interface HTMLPostTabPanelElement extends Components.PostTabPanel, HTMLStencilElement {
    }
    var HTMLPostTabPanelElement: {
        prototype: HTMLPostTabPanelElement;
        new (): HTMLPostTabPanelElement;
    };
    interface HTMLPostTabsElementEventMap {
        "postChange": string;
    }
    interface HTMLPostTabsElement extends Components.PostTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPostTabsElementEventMap>(type: K, listener: (this: HTMLPostTabsElement, ev: PostTabsCustomEvent<HTMLPostTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPostTabsElementEventMap>(type: K, listener: (this: HTMLPostTabsElement, ev: PostTabsCustomEvent<HTMLPostTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPostTabsElement: {
        prototype: HTMLPostTabsElement;
        new (): HTMLPostTabsElement;
    };
    interface HTMLPostTagElement extends Components.PostTag, HTMLStencilElement {
    }
    var HTMLPostTagElement: {
        prototype: HTMLPostTagElement;
        new (): HTMLPostTagElement;
    };
    interface HTMLPostTogglebuttonElement extends Components.PostTogglebutton, HTMLStencilElement {
    }
    var HTMLPostTogglebuttonElement: {
        prototype: HTMLPostTogglebuttonElement;
        new (): HTMLPostTogglebuttonElement;
    };
    interface HTMLPostTooltipElement extends Components.PostTooltip, HTMLStencilElement {
    }
    var HTMLPostTooltipElement: {
        prototype: HTMLPostTooltipElement;
        new (): HTMLPostTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "post-accordion": HTMLPostAccordionElement;
        "post-accordion-item": HTMLPostAccordionItemElement;
        "post-avatar": HTMLPostAvatarElement;
        "post-back-to-top": HTMLPostBackToTopElement;
        "post-banner": HTMLPostBannerElement;
        "post-breadcrumb": HTMLPostBreadcrumbElement;
        "post-breadcrumb-item": HTMLPostBreadcrumbItemElement;
        "post-card-control": HTMLPostCardControlElement;
        "post-closebutton": HTMLPostClosebuttonElement;
        "post-collapsible": HTMLPostCollapsibleElement;
        "post-collapsible-trigger": HTMLPostCollapsibleTriggerElement;
        "post-footer": HTMLPostFooterElement;
        "post-header": HTMLPostHeaderElement;
        "post-icon": HTMLPostIconElement;
        "post-language-option": HTMLPostLanguageOptionElement;
        "post-language-switch": HTMLPostLanguageSwitchElement;
        "post-linkarea": HTMLPostLinkareaElement;
        "post-list": HTMLPostListElement;
        "post-list-item": HTMLPostListItemElement;
        "post-logo": HTMLPostLogoElement;
        "post-mainnavigation": HTMLPostMainnavigationElement;
        "post-megadropdown": HTMLPostMegadropdownElement;
        "post-megadropdown-trigger": HTMLPostMegadropdownTriggerElement;
        "post-menu": HTMLPostMenuElement;
        "post-menu-item": HTMLPostMenuItemElement;
        "post-menu-trigger": HTMLPostMenuTriggerElement;
        "post-popover": HTMLPostPopoverElement;
        "post-popovercontainer": HTMLPostPopovercontainerElement;
        "post-rating": HTMLPostRatingElement;
        "post-tab-header": HTMLPostTabHeaderElement;
        "post-tab-panel": HTMLPostTabPanelElement;
        "post-tabs": HTMLPostTabsElement;
        "post-tag": HTMLPostTagElement;
        "post-togglebutton": HTMLPostTogglebuttonElement;
        "post-tooltip": HTMLPostTooltipElement;
    }
}
declare namespace LocalJSX {
    interface PostAccordion {
        /**
          * Defines the hierarchical level of the `post-accordion-item` headers within the headings structure.
         */
        "headingLevel": HeadingLevel;
        /**
          * If `true`, multiple `post-accordion-item` can be open at the same time.
         */
        "multiple"?: boolean;
    }
    interface PostAccordionItem {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
         */
        "collapsed"?: boolean;
        /**
          * Defines the hierarchical level of the accordion item header within the headings structure.
          * @deprecated set the `heading-level` property on the parent `post-accordion` instead.
         */
        "headingLevel"?: HeadingLevel;
    }
    interface PostAvatar {
        /**
          * Defines the users email address associated with a gravatar profile picture.
         */
        "email"?: string;
        /**
          * Defines the users firstname.
         */
        "firstname": string;
        /**
          * Defines the users lastname.
         */
        "lastname"?: string;
        /**
          * Defines the company internal userId.<div className="mb-1 banner banner-warning banner-sm">Can only be used on post.ch domains!</div>
         */
        "userid"?: string;
    }
    interface PostBackToTop {
        /**
          * The label of the back-to-top button, intended solely for accessibility purposes. This label is always hidden from view.
         */
        "label": string;
    }
    interface PostBanner {
        /**
          * The label to use for the close button of a dismissible banner.
         */
        "dismissLabel"?: string;
        /**
          * If `true`, a close button (×) is displayed and the banner can be dismissed by the user.
         */
        "dismissible"?: boolean;
        /**
          * The icon to display in the banner. By default, the icon depends on the banner type.  If `none`, no icon is displayed.
         */
        "icon"?: string;
        /**
          * An event emitted when the banner element is dismissed, after the transition. It has no payload and only relevant for dismissible banners.
         */
        "onPostDismissed"?: (event: PostBannerCustomEvent<void>) => void;
        /**
          * The type of the banner.
         */
        "type"?: BannerType;
    }
    interface PostBreadcrumb {
        /**
          * The text label for the home breadcrumb item.
         */
        "homeText"?: string;
        /**
          * The URL for the home breadcrumb item.
         */
        "homeUrl"?: string;
    }
    interface PostBreadcrumbItem {
        /**
          * The optional URL to which the breadcrumb item will link.
         */
        "url"?: string | URL;
    }
    /**
     * @class PostCardControl - representing a stencil component
     */
    interface PostCardControl {
        /**
          * Defines the `checked` attribute of the control. If `true`, the control is selected at its value will be included in the forms' data.
         */
        "checked"?: boolean;
        /**
          * Defines the description in the control-label.
         */
        "description"?: string;
        /**
          * Defines the `disabled` attribute of the control. If `true`, the user can not interact with the control and the controls value will not be included in the forms' data.
         */
        "disabled"?: boolean;
        /**
          * Defines the icon `name` inside the card. <span className="banner banner-sm banner-info">If not set the icon will not show up.</span>
         */
        "icon"?: string;
        /**
          * Defines the text in the control-label.
         */
        "label": string;
        /**
          * Defines the `name` attribute of the control. <span className="banner banner-sm banner-info">This is a required property, when the control should participate in a native `form`. If not specified, a native `form` will never contain this controls value.</span> <span className="banner banner-sm banner-info">This is a required property, when the control is used with type `radio`.</span>
         */
        "name"?: string;
        /**
          * An event emitted whenever the components checked state is toggled. The event payload (emitted under `event.detail.state`) is a boolean: `true` if the component is checked, `false` if it is unchecked. <span className="banner banner-sm banner-info">If the component is used with type `radio`, it will only emit this event, when the checked state is changing to `true`.</span>
         */
        "onPostChange"?: (event: PostCardControlCustomEvent<{ state: boolean; value: string }>) => void;
        /**
          * An event emitted whenever the components checked state is toggled. The event payload (emitted under `event.detail.state`) is a boolean: `true` if the component is checked, `false` if it is unchecked.
         */
        "onPostInput"?: (event: PostCardControlCustomEvent<{ state: boolean; value: string }>) => void;
        /**
          * Defines the `type` attribute of the control.
         */
        "type": 'checkbox' | 'radio';
        /**
          * Defines the validation `validity` of the control. To reset validity to an undefined state, simply remove the attribute from the control.
         */
        "validity"?: null | 'true' | 'false';
        /**
          * Defines the `value` attribute of the control. <span className="banner banner-sm banner-info">This is a required property, when the control is used with type `radio`.</span>
         */
        "value"?: string;
    }
    interface PostClosebutton {
    }
    interface PostCollapsible {
        /**
          * If `true`, the element is collapsed otherwise it is displayed.
         */
        "collapsed"?: boolean;
        /**
          * An event emitted when the collapse element is shown or hidden, before the transition.  The event payload is a boolean: `true` if the collapsible was opened, `false` if it was closed.
         */
        "onPostToggle"?: (event: PostCollapsibleCustomEvent<boolean>) => void;
    }
    interface PostCollapsibleTrigger {
        /**
          * Link the trigger to a post-collapsible with this id
         */
        "for"?: string;
    }
    interface PostFooter {
        /**
          * The label to add to the footer (visually hidden).
         */
        "label": string;
    }
    interface PostHeader {
        /**
          * An event emitted when the device has changed
         */
        "onPostUpdateDevice"?: (event: PostHeaderCustomEvent<DEVICE_SIZE>) => void;
    }
    /**
     * @class PostIcon - representing a stencil component
     */
    interface PostIcon {
        /**
          * The name of the animation.
         */
        "animation"?: Animation | null;
        /**
          * The base path, where the icons are located (must be a public url).<br/>Leave this field empty to use the default cdn url.
         */
        "base"?: string | null;
        /**
          * When set to `true`, the icon will be flipped horizontally.
         */
        "flipH"?: boolean;
        /**
          * When set to `true`, the icon will be flipped vertically.
         */
        "flipV"?: boolean;
        /**
          * The name/id of the icon (e.g. 1000, 1001, ...).
         */
        "name": string;
        /**
          * The number of degree for the css rotate transformation.
         */
        "rotate"?: number | null;
        /**
          * The number for the css scale transformation.
         */
        "scale"?: number | null;
    }
    interface PostLanguageOption {
        /**
          * If set to `true`, the language option is considered the current language for the page.
         */
        "active"?: boolean;
        /**
          * The ISO 639 language code, formatted according to [RFC 5646 (also known as BCP 47)](https://datatracker.ietf.org/doc/html/rfc5646). For example, "de".
         */
        "code": string;
        /**
          * The full name of the language. For example, "Deutsch".
         */
        "name"?: string;
        /**
          * An event emitted when the language option is clicked. The payload is the ISO 639 code of the language.
         */
        "onPostChange"?: (event: PostLanguageOptionCustomEvent<string>) => void;
        /**
          * An event emitted when the language option is initially active. The payload is the ISO 639 code of the language.
         */
        "onPostLanguageOptionInitiallyActive"?: (event: PostLanguageOptionCustomEvent<string>) => void;
        /**
          * The URL used for the href attribute of the internal anchor. This field is optional; if not provided, a button will be used internally instead of an anchor.
         */
        "url"?: string;
        /**
          * To communicate the variant prop from the parent (post-language-switch) component to the child (post-language-option) component. See parent docs for a description about the property itself.
         */
        "variant"?: SwitchVariant | null;
    }
    interface PostLanguageSwitch {
        /**
          * A title for the list of language options
         */
        "caption"?: string;
        /**
          * A descriptive text for the list of language options
         */
        "description"?: string;
        /**
          * Whether the component is rendered as a list or a menu
         */
        "variant"?: SwitchVariant;
    }
    interface PostLinkarea {
    }
    interface PostList {
        /**
          * The list can become horizontal by setting `horizontal="true"` or just `horizontal`
         */
        "horizontal"?: boolean;
        /**
          * If `true`, the list title will be hidden. Otherwise, it will be displayed.`
         */
        "titleHidden"?: boolean;
    }
    interface PostListItem {
    }
    interface PostLogo {
        /**
          * The URL to which the user is redirected upon clicking the logo.
         */
        "url"?: string | URL;
    }
    interface PostMainnavigation {
    }
    interface PostMegadropdown {
        /**
          * Emits when the dropdown is shown or hidden. The event payload is an object. `isVisible` is true when the dropdown gets opened and false when it gets closed `focusParent` determines whether after the closing of the mega dropdown, the focus should go back to the trigger parent or naturally go to the next focusable element in the page
         */
        "onPostToggleMegadropdown"?: (event: PostMegadropdownCustomEvent<{ isVisible: boolean; focusParent?: boolean }>) => void;
    }
    interface PostMegadropdownTrigger {
        /**
          * ID of the mega dropdown element that this trigger is linked to. Used to open and close the specified mega dropdown.
         */
        "for": string;
    }
    interface PostMenu {
        /**
          * Emits when the menu is shown or hidden. The event payload is a boolean: `true` when the menu was opened, `false` when it was closed.
         */
        "onToggleMenu"?: (event: PostMenuCustomEvent<boolean>) => void;
        /**
          * Defines the placement of the tooltip according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
    }
    interface PostMenuItem {
    }
    interface PostMenuTrigger {
        /**
          * ID of the menu element that this trigger is linked to. Used to open and close the specified menu.
         */
        "for": string;
    }
    interface PostPopover {
        /**
          * Show a little indicator arrow
         */
        "arrow"?: boolean;
        /**
          * Define the caption of the close button for assistive technology
         */
        "closeButtonCaption": string;
        /**
          * Defines the placement of the popover according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Popoverss are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
    }
    interface PostPopovercontainer {
        /**
          * Whether or not to display a little pointer arrow
         */
        "arrow"?: boolean;
        /**
          * Gap between the edge of the page and the popover
         */
        "edgeGap"?: number;
        /**
          * Whether or not the popover should close when user clicks outside of it
         */
        "manualClose"?: boolean;
        /**
          * Fires whenever the popover gets shown or hidden, passing the new state in event.details as a boolean
         */
        "onPostToggle"?: (event: PostPopovercontainerCustomEvent<boolean>) => void;
        /**
          * Defines the placement of the tooltip according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
        /**
          * Enables a safespace through which the cursor can be moved without the popover being disabled
         */
        "safeSpace"?: 'triangle' | 'trapezoid';
    }
    interface PostRating {
        /**
          * Defines the rating that the component should show.
         */
        "currentRating"?: number;
        /**
          * Defines a hidden label for the component.
         */
        "label"?: string;
        /**
          * An event emitted whenever the component's value has changed (on blur). The event payload can be used like so: `event.detail.value`.
         */
        "onPostChange"?: (event: PostRatingCustomEvent<{ value: number }>) => void;
        /**
          * An event emitted whenever the component's value has changed (on input). The event payload can be used like so: `event.detail.value`.
         */
        "onPostInput"?: (event: PostRatingCustomEvent<{ value: number }>) => void;
        /**
          * Defines if the component is readonly or not. This usually should be used together with the `currentRating` property.
         */
        "readonly"?: boolean;
        /**
          * Defines the total amount of stars rendered in the component.
         */
        "stars"?: number;
    }
    interface PostTabHeader {
        /**
          * The name of the panel controlled by the tab header.
         */
        "panel"?: HTMLPostTabPanelElement['name'];
    }
    interface PostTabPanel {
        /**
          * The name of the panel, used to associate it with a tab header.
         */
        "name"?: string;
    }
    interface PostTabs {
        /**
          * The name of the panel that is initially shown. If not specified, it defaults to the panel associated with the first tab.  **Changing this value after initialization has no effect.**
         */
        "activePanel"?: HTMLPostTabPanelElement['name'];
        /**
          * An event emitted after the active tab changes, when the fade in transition of its associated panel is finished. The payload is the name of the newly shown panel.
         */
        "onPostChange"?: (event: PostTabsCustomEvent<string>) => void;
    }
    interface PostTag {
        /**
          * Defines the icon `name` inside of the component. <span className="banner banner-sm banner-info">If not set the icon will not show up.</span> To learn which icons are available, please visit our <a href="/?path=/docs/5704bdc4-c5b5-45e6-b123-c54d01fce2f1--docs">icon library</a>.
         */
        "icon"?: null | string;
        /**
          * Defines the size of the component.
         */
        "size"?: null | 'sm';
        /**
          * Defines the color variant of the component.
         */
        "variant"?: 'white' | 'info' | 'success' | 'error' | 'warning' | 'yellow';
    }
    interface PostTogglebutton {
        /**
          * If `true`, the button is in the "on" state, otherwise it is in the "off" state.
         */
        "toggled"?: boolean;
    }
    interface PostTooltip {
        /**
          * Wheter or not to display a little pointer arrow
         */
        "arrow"?: boolean;
        /**
          * If `true`, the tooltip is displayed a few milliseconds after it is triggered
         */
        "delayed"?: boolean;
        /**
          * Defines the placement of the tooltip according to the floating-ui options available at https://floating-ui.com/docs/computePosition#placement. Tooltips are automatically flipped to the opposite side if there is not enough available space and are shifted towards the viewport if they would overlap edge boundaries.
         */
        "placement"?: Placement;
    }
    interface IntrinsicElements {
        "post-accordion": PostAccordion;
        "post-accordion-item": PostAccordionItem;
        "post-avatar": PostAvatar;
        "post-back-to-top": PostBackToTop;
        "post-banner": PostBanner;
        "post-breadcrumb": PostBreadcrumb;
        "post-breadcrumb-item": PostBreadcrumbItem;
        "post-card-control": PostCardControl;
        "post-closebutton": PostClosebutton;
        "post-collapsible": PostCollapsible;
        "post-collapsible-trigger": PostCollapsibleTrigger;
        "post-footer": PostFooter;
        "post-header": PostHeader;
        "post-icon": PostIcon;
        "post-language-option": PostLanguageOption;
        "post-language-switch": PostLanguageSwitch;
        "post-linkarea": PostLinkarea;
        "post-list": PostList;
        "post-list-item": PostListItem;
        "post-logo": PostLogo;
        "post-mainnavigation": PostMainnavigation;
        "post-megadropdown": PostMegadropdown;
        "post-megadropdown-trigger": PostMegadropdownTrigger;
        "post-menu": PostMenu;
        "post-menu-item": PostMenuItem;
        "post-menu-trigger": PostMenuTrigger;
        "post-popover": PostPopover;
        "post-popovercontainer": PostPopovercontainer;
        "post-rating": PostRating;
        "post-tab-header": PostTabHeader;
        "post-tab-panel": PostTabPanel;
        "post-tabs": PostTabs;
        "post-tag": PostTag;
        "post-togglebutton": PostTogglebutton;
        "post-tooltip": PostTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "post-accordion": LocalJSX.PostAccordion & JSXBase.HTMLAttributes<HTMLPostAccordionElement>;
            "post-accordion-item": LocalJSX.PostAccordionItem & JSXBase.HTMLAttributes<HTMLPostAccordionItemElement>;
            "post-avatar": LocalJSX.PostAvatar & JSXBase.HTMLAttributes<HTMLPostAvatarElement>;
            "post-back-to-top": LocalJSX.PostBackToTop & JSXBase.HTMLAttributes<HTMLPostBackToTopElement>;
            "post-banner": LocalJSX.PostBanner & JSXBase.HTMLAttributes<HTMLPostBannerElement>;
            "post-breadcrumb": LocalJSX.PostBreadcrumb & JSXBase.HTMLAttributes<HTMLPostBreadcrumbElement>;
            "post-breadcrumb-item": LocalJSX.PostBreadcrumbItem & JSXBase.HTMLAttributes<HTMLPostBreadcrumbItemElement>;
            /**
             * @class PostCardControl - representing a stencil component
             */
            "post-card-control": LocalJSX.PostCardControl & JSXBase.HTMLAttributes<HTMLPostCardControlElement>;
            "post-closebutton": LocalJSX.PostClosebutton & JSXBase.HTMLAttributes<HTMLPostClosebuttonElement>;
            "post-collapsible": LocalJSX.PostCollapsible & JSXBase.HTMLAttributes<HTMLPostCollapsibleElement>;
            "post-collapsible-trigger": LocalJSX.PostCollapsibleTrigger & JSXBase.HTMLAttributes<HTMLPostCollapsibleTriggerElement>;
            "post-footer": LocalJSX.PostFooter & JSXBase.HTMLAttributes<HTMLPostFooterElement>;
            "post-header": LocalJSX.PostHeader & JSXBase.HTMLAttributes<HTMLPostHeaderElement>;
            /**
             * @class PostIcon - representing a stencil component
             */
            "post-icon": LocalJSX.PostIcon & JSXBase.HTMLAttributes<HTMLPostIconElement>;
            "post-language-option": LocalJSX.PostLanguageOption & JSXBase.HTMLAttributes<HTMLPostLanguageOptionElement>;
            "post-language-switch": LocalJSX.PostLanguageSwitch & JSXBase.HTMLAttributes<HTMLPostLanguageSwitchElement>;
            "post-linkarea": LocalJSX.PostLinkarea & JSXBase.HTMLAttributes<HTMLPostLinkareaElement>;
            "post-list": LocalJSX.PostList & JSXBase.HTMLAttributes<HTMLPostListElement>;
            "post-list-item": LocalJSX.PostListItem & JSXBase.HTMLAttributes<HTMLPostListItemElement>;
            "post-logo": LocalJSX.PostLogo & JSXBase.HTMLAttributes<HTMLPostLogoElement>;
            "post-mainnavigation": LocalJSX.PostMainnavigation & JSXBase.HTMLAttributes<HTMLPostMainnavigationElement>;
            "post-megadropdown": LocalJSX.PostMegadropdown & JSXBase.HTMLAttributes<HTMLPostMegadropdownElement>;
            "post-megadropdown-trigger": LocalJSX.PostMegadropdownTrigger & JSXBase.HTMLAttributes<HTMLPostMegadropdownTriggerElement>;
            "post-menu": LocalJSX.PostMenu & JSXBase.HTMLAttributes<HTMLPostMenuElement>;
            "post-menu-item": LocalJSX.PostMenuItem & JSXBase.HTMLAttributes<HTMLPostMenuItemElement>;
            "post-menu-trigger": LocalJSX.PostMenuTrigger & JSXBase.HTMLAttributes<HTMLPostMenuTriggerElement>;
            "post-popover": LocalJSX.PostPopover & JSXBase.HTMLAttributes<HTMLPostPopoverElement>;
            "post-popovercontainer": LocalJSX.PostPopovercontainer & JSXBase.HTMLAttributes<HTMLPostPopovercontainerElement>;
            "post-rating": LocalJSX.PostRating & JSXBase.HTMLAttributes<HTMLPostRatingElement>;
            "post-tab-header": LocalJSX.PostTabHeader & JSXBase.HTMLAttributes<HTMLPostTabHeaderElement>;
            "post-tab-panel": LocalJSX.PostTabPanel & JSXBase.HTMLAttributes<HTMLPostTabPanelElement>;
            "post-tabs": LocalJSX.PostTabs & JSXBase.HTMLAttributes<HTMLPostTabsElement>;
            "post-tag": LocalJSX.PostTag & JSXBase.HTMLAttributes<HTMLPostTagElement>;
            "post-togglebutton": LocalJSX.PostTogglebutton & JSXBase.HTMLAttributes<HTMLPostTogglebuttonElement>;
            "post-tooltip": LocalJSX.PostTooltip & JSXBase.HTMLAttributes<HTMLPostTooltipElement>;
        }
    }
}
