@use 'sass:map';

@use '../functions/tokens';
@use '../mixins/media';
@use '../tokens/components';
@use '../variables/breakpoints';

tokens.$default-map: components.$post-container;

@each $class in (container, container-fluid) {
  .#{$class} {
    width: 100%;
    margin-inline: auto;
    --post-container-max-width: #{tokens.get('grid-max-width')};

    @each $breakpoint in map.keys(breakpoints.$grid-breakpoints) {
      @include media.min($breakpoint) {
        $gutter: tokens.get('grid-gutter-#{$breakpoint}');
        $padding: tokens.get('grid-padding-#{$breakpoint}');

        // The `.row` has a negative margin equal to half the gutter size.
        // To prevent content from overflowing, the container needs to have
        // a padding of at least half the gutter size to offset this negative margin.
        padding-inline: max(#{$padding}, calc(0.5 * #{$gutter}));

        // Adjust offset according to container class
        @if $class == container {
          // If `.container` the offset will be-> padding-inline + max(0px, (100vw - container-max-width)/2))
          --post-container-offset: calc(
            max(#{$padding}, calc(0.5 * #{$gutter})) +
              max(0px, calc((100vw - var(--post-container-max-width)) / 2))
          );
        } @else {
          // If `.container-fluid` the offset will be: padding-inline
          --post-container-offset: max(#{$padding}, calc(0.5 * #{$gutter}));
        }
      }
    }

    // Apply max-width only to `.container`
    @if $class == container {
      max-width: var(--post-container-max-width);
    }
  }
}
