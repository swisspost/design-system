import StyleDictionary from 'style-dictionary';
import { register } from '@tokens-studio/sd-transforms';
import {
  BASE_FONT_SIZE,
  FILE_HEADER,
  NO_UNITLESS_ZERO_VALUE_TOKEN_TYPES,
  PX_TO_REM_TOKEN_TYPE,
} from './constants.js';
register(StyleDictionary);
import { DesignToken } from 'style-dictionary/types';

/**
 * @function StyleDictionary.registerFileHeader()
 * Defined a custom StyleDictionary file header.
 *
 * swisspost/file-header:
 * Used to define a custom default file header for all output files, generated by StyleDictionary.
 */
StyleDictionary.registerFileHeader({
  name: 'swisspost/file-header',
  fileHeader: () => {
    return FILE_HEADER;
  },
});

/**
 * @function StyleDictionary.registerTransform()
 * Defines a custom StyleDictionary transform.
 *
 * swisspost/scss-no-unitless-zero-values:
 * Used to keep pixel unit for zero values.
 * This is necessary, so these values can also be used within a css `calc()` function:
 * > Note: Because <number-token>s are always interpreted as <number>s or <integer>s, "unitless 0" <length>s arenâ€™t supported in calc(). That is, width: calc(0 + 5px); is invalid, even though both width: 0; and width: 5px; are valid.
 * > Source: https://drafts.csswg.org/css-values-3/#calc-type-checking
 */

StyleDictionary.registerTransform({
  name: 'swisspost/scss-no-unitless-zero-values',
  type: 'value',
  filter: token => {
    const usesDtcg = token.$type && token.$value;
    let transformType = false;
    const typeToCheck = usesDtcg ? (token.$type as string) : (token.type as string);
    transformType = NO_UNITLESS_ZERO_VALUE_TOKEN_TYPES.includes(typeToCheck);
    if (transformType) {
      return token[usesDtcg ? '$value' : 'value'] === '0';
    } else {
      return false;
    }
  },
  transform: token => {
    const usesDtcg = token.$type && token.$value;
    return token[usesDtcg ? '$value' : 'value'] + 'px';
  },
});

/**
 * @function StyleDictionary.registerTransform()
 * Defines a custom StyleDictionary transform.
 *
 * swisspost/px-to-rem:
 * Used to transform font sizes from px to rem
 * This ensures accessible font-sizes
 */

StyleDictionary.registerTransform({
  name: 'swisspost/px-to-rem',
  type: 'value',
  filter: token => {
    const usesDtcg = token.$type && token.$value;
    return token[usesDtcg ? '$type' : 'type'] === PX_TO_REM_TOKEN_TYPE;
  },
  transform: token => {
    const usesDtcg = token.$type && token.$value;
    const baseFontSize = BASE_FONT_SIZE;
    let value = token[usesDtcg ? '$value' : 'value'];
    if (typeof value === 'string' && value.includes('px')) {
      // Convert value to a number
      value = parseFloat(value);
    }
    return `${value / baseFontSize}rem`;
  },
});

/**
 * @function StyleDictionary.registerPreprocessor()
 * Defines a custom StyleDictionary preprocessor.
 *
 * swisspost/box-shadow-keep-refs-workaround:
 * Used to keep the references in the box-shadow token values, which otherwise would be resolved with the actual values.
 * This is a known bug in the current StyleDictionary version: https://github.com/amzn/style-dictionary/issues/1318.
 */

StyleDictionary.registerPreprocessor({
  name: 'swisspost/box-shadow-keep-refs-workaround',
  preprocessor: dictionary => {
    traverse(dictionary);

    function traverse(context: DesignToken) {
      Object.entries(context).forEach(([key, value]) => {
        const usesDtcg = context[key].$type && context[key].$value;
        const isToken = context[key][usesDtcg ? '$type' : 'type'] !== undefined;
        const tokenType = context[key][usesDtcg ? '$type' : 'type'];
        const tokenValue = context[key][usesDtcg ? '$value' : 'value'];

        if (typeof context[key] === 'object' && context[key] !== null) {
          if (isToken) {
            if (tokenType === 'shadow' && typeof tokenValue === 'string') {
              context[key].$extensions['studio.tokens'].boxShadowKeepRefsWorkaroundValue =
                `${tokenValue.replace(/[{}]/g, match => (match === '{' ? '[[' : ']]'))}`;
            }
          } else if (typeof value === 'object' && value !== null) {
            traverse(value);
          }
        }
      });
    }

    return dictionary;
  },
});

/**
 * Filters only the component source tokens.
 */
StyleDictionary.registerFilter({
  name: 'swisspost/source-tokens-filter',
  filter: token => token.isSource,
});

export default StyleDictionary;
